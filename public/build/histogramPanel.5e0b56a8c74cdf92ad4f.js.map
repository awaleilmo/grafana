{"version":3,"file":"histogramPanel.5e0b56a8c74cdf92ad4f.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/status-history/utils.ts","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipHeader.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipContent.tsx","webpack://grafana/./public/app/plugins/panel/histogram/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/histogram/Histogram.tsx","webpack://grafana/./public/app/plugins/panel/histogram/HistogramTooltip.tsx","webpack://grafana/./public/app/plugins/panel/histogram/HistogramPanel.tsx","webpack://grafana/./public/app/plugins/panel/histogram/config.ts","webpack://grafana/./public/app/plugins/panel/histogram/migrations.ts","webpack://grafana/./public/app/plugins/panel/histogram/utils.ts","webpack://grafana/./public/app/plugins/panel/histogram/module.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/utils.ts","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipColorIndicator.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipRow.tsx"],"sourcesContent":["import { DataFrame, ActionModel, Field, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { getActions } from 'app/features/actions/utils';\n\nexport const getDataLinks = (field: Field, rowIdx: number) => {\n  const links: Array<LinkModel<Field>> = [];\n\n  if ((field.config.links?.length ?? 0) > 0 && field.getLinks != null) {\n    const v = field.values[rowIdx];\n    const disp = field.display ? field.display(v) : { text: `${v}`, numeric: +v };\n\n    const linkLookup = new Set<string>();\n\n    field.getLinks({ calculatedValue: disp, valueRowIndex: rowIdx }).forEach((link) => {\n      const key = `${link.title}/${link.href}`;\n      if (!linkLookup.has(key)) {\n        links.push(link);\n        linkLookup.add(key);\n      }\n    });\n  }\n\n  return links;\n};\n\nexport const getAllFrameActions = (dataFrame: DataFrame) => {};\n\nexport const getFieldActions = (\n  dataFrame: DataFrame,\n  field: Field,\n  replaceVars: InterpolateFunction,\n  rowIndex: number\n) => {\n  const actions: Array<ActionModel<Field>> = [];\n  const actionLookup = new Set<string>();\n\n  const actionsModel = getActions(dataFrame, field, field.state!.scopedVars!, replaceVars, field.config.actions ?? [], {\n    valueRowIndex: rowIndex,\n  });\n\n  actionsModel.forEach((action) => {\n    const key = `${action.title}`;\n    if (!actionLookup.has(key)) {\n      actions.push(action);\n      actionLookup.add(key);\n    }\n  });\n\n  return actions;\n};\n","import { css } from '@emotion/css';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\n\nimport { VizTooltipRow } from './VizTooltipRow';\nimport { VizTooltipItem } from './types';\n\ninterface Props {\n  item: VizTooltipItem;\n  isPinned: boolean;\n}\nexport const VizTooltipHeader = ({ item, isPinned }: Props) => {\n  const styles = useStyles2(getStyles);\n\n  const { label, value, color, colorIndicator } = item;\n\n  return (\n    <div className={styles.wrapper}>\n      <VizTooltipRow\n        label={label}\n        value={value}\n        color={color}\n        colorIndicator={colorIndicator}\n        marginRight={'22px'}\n        isPinned={isPinned}\n      />\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    flex: 1,\n    padding: theme.spacing(1),\n    lineHeight: 1,\n  }),\n});\n","import { css } from '@emotion/css';\nimport { CSSProperties, ReactNode } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\n\nimport { VizTooltipRow } from './VizTooltipRow';\nimport { VizTooltipItem } from './types';\n\ninterface VizTooltipContentProps {\n  items: VizTooltipItem[];\n  children?: ReactNode;\n  scrollable?: boolean;\n  isPinned: boolean;\n  maxHeight?: number;\n}\n\nexport const VizTooltipContent = ({\n  items,\n  children,\n  isPinned,\n  scrollable = false,\n  maxHeight,\n}: VizTooltipContentProps) => {\n  const styles = useStyles2(getStyles);\n\n  const scrollableStyle: CSSProperties = scrollable\n    ? {\n        maxHeight: maxHeight,\n        overflowY: 'auto',\n      }\n    : {};\n\n  return (\n    <div className={styles.wrapper} style={scrollableStyle}>\n      {items.map(({ label, value, color, colorIndicator, colorPlacement, isActive, lineStyle, isHiddenFromViz }, i) => (\n        <VizTooltipRow\n          key={i}\n          label={label}\n          value={value}\n          color={color}\n          colorIndicator={colorIndicator}\n          colorPlacement={colorPlacement}\n          isActive={isActive}\n          justify={'space-between'}\n          isPinned={isPinned}\n          lineStyle={lineStyle}\n          showValueScroll={!scrollable}\n          isHiddenFromViz={isHiddenFromViz}\n        />\n      ))}\n      {children}\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    flex: 1,\n    gap: 2,\n    borderTop: `1px solid ${theme.colors.border.weak}`,\n    padding: theme.spacing(1),\n  }),\n});\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip {\n  /**\n   * Bucket count (approx)\n   */\n  bucketCount?: number;\n  /**\n   * Offset buckets by this amount\n   */\n  bucketOffset?: number;\n  /**\n   * Size of each bucket\n   */\n  bucketSize?: number;\n  /**\n   * Combines multiple series into a single histogram\n   */\n  combine?: boolean;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  bucketCount: 30,\n  bucketOffset: 0,\n};\n\nexport interface FieldConfig extends common.AxisConfig, common.HideableFieldConfig, common.StackableFieldConfig {\n  /**\n   * Controls the fill opacity of the bars.\n   */\n  fillOpacity?: number;\n  /**\n   * Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.\n   * Gradient appearance is influenced by the Fill opacity setting.\n   */\n  gradientMode?: common.GraphGradientMode;\n  /**\n   * Controls line width of the bars.\n   */\n  lineWidth?: number;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 80,\n  gradientMode: common.GraphGradientMode.None,\n  lineWidth: 1,\n};\n","import * as React from 'react';\nimport uPlot, { AlignedData } from 'uplot';\n\nimport {\n  DataFrame,\n  FieldType,\n  formattedValueToString,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  GrafanaTheme2,\n  roundDecimals,\n  histogramBucketSizes,\n  histogramFrameBucketMaxFieldName,\n} from '@grafana/data';\nimport { VizLegendOptions, ScaleDistribution, AxisPlacement, ScaleDirection, ScaleOrientation } from '@grafana/schema';\nimport {\n  Themeable2,\n  UPlotConfigBuilder,\n  UPlotChart,\n  VizLayout,\n  PlotLegend,\n  measureText,\n  UPLOT_AXIS_FONT_SIZE,\n} from '@grafana/ui';\nimport { getStackingGroups, preparePlotData2 } from '@grafana/ui/internal';\n\nimport { defaultFieldConfig, FieldConfig, Options } from './panelcfg.gen';\n\nfunction incrRoundDn(num: number, incr: number) {\n  return Math.floor(num / incr) * incr;\n}\n\nfunction incrRoundUp(num: number, incr: number) {\n  return Math.ceil(num / incr) * incr;\n}\n\nexport interface HistogramProps extends Themeable2 {\n  options: Options; // used for diff\n  alignedFrame: DataFrame; // This could take HistogramFields\n  bucketCount?: number;\n  bucketSize: number;\n  width: number;\n  height: number;\n  structureRev?: number; // a number that will change when the frames[] structure changes\n  legend: VizLegendOptions;\n  rawSeries?: DataFrame[];\n  children?: (builder: UPlotConfigBuilder, frame: DataFrame, xMinOnlyFrame: DataFrame) => React.ReactNode;\n}\n\nexport function getBucketSize(frame: DataFrame) {\n  // assumes BucketMin is fields[0] and BucktMax is fields[1]\n  return frame.fields[0].type === FieldType.string\n    ? 1\n    : roundDecimals(frame.fields[1].values[0] - frame.fields[0].values[0], 9);\n}\n\nexport function getBucketSize1(frame: DataFrame) {\n  // assumes BucketMin is fields[0] and BucktMax is fields[1]\n  return frame.fields[0].type === FieldType.string\n    ? 1\n    : roundDecimals(frame.fields[1].values[1] - frame.fields[0].values[1], 9);\n}\n\nconst prepConfig = (frame: DataFrame, theme: GrafanaTheme2) => {\n  // todo: scan all values in BucketMin and BucketMax fields to assert if uniform bucketSize\n\n  // since this is x axis range, this should ideally come from xMin or xMax fields, not a count field\n  // though both methods are probably hacks, and we should just accept explicit opts into this prepConfig\n  let { min: xScaleMin, max: xScaleMax } = frame.fields[2].config;\n\n  let builder = new UPlotConfigBuilder();\n\n  let isOrdinalX = frame.fields[0].type === FieldType.string;\n\n  // assumes BucketMin is fields[0] and BucktMax is fields[1]\n  let bucketSize = getBucketSize(frame);\n  let bucketSize1 = getBucketSize1(frame);\n\n  let bucketFactor = bucketSize1 / bucketSize;\n\n  let useLogScale = bucketSize1 !== bucketSize; // (imperfect floats)\n\n  // splits shifter, to ensure splits always start at first bucket\n  let xSplits: uPlot.Axis.Splits = (u, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n    /** @ts-ignore */\n    let minSpace = u.axes[axisIdx]._space;\n    let bucketWidth = u.valToPos(u.data[0][0] + bucketSize, 'x') - u.valToPos(u.data[0][0], 'x');\n\n    let firstSplit = incrRoundDn(xScaleMin ?? u.data[0][0], bucketSize);\n    let lastSplit = incrRoundUp(xScaleMax ?? u.data[0][u.data[0].length - 1] + bucketSize, bucketSize);\n\n    let splits = [];\n    let skip = Math.ceil(minSpace / bucketWidth);\n\n    for (let i = 0, s = firstSplit; s <= lastSplit; i++, s += bucketSize) {\n      !(i % skip) && splits.push(s);\n    }\n\n    return splits;\n  };\n\n  builder.addScale({\n    scaleKey: 'x', // bukkits\n    isTime: false,\n    distribution: isOrdinalX\n      ? ScaleDistribution.Ordinal\n      : useLogScale\n        ? ScaleDistribution.Log\n        : ScaleDistribution.Linear,\n    log: 2,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: useLogScale\n      ? (u, wantedMin, wantedMax) => {\n          return uPlot.rangeLog(wantedMin, wantedMax * bucketFactor, 2, true);\n        }\n      : (u, wantedMin, wantedMax) => {\n          // these settings will prevent zooming, probably okay?\n          if (xScaleMin != null) {\n            wantedMin = xScaleMin;\n          }\n          if (xScaleMax != null) {\n            wantedMax = xScaleMax;\n          }\n\n          let fullRangeMax = u.data[0][u.data[0].length - 1];\n\n          // isOrdinalX is when we have classic histograms, which are LE, ordinal X, and already have 0 dummy bucket prepended\n          // else we have calculated histograms which are GE and cardinal+linear X, and have no next dummy bucket appended\n          wantedMin = incrRoundUp(wantedMin, bucketSize);\n          wantedMax =\n            !isOrdinalX && wantedMax === fullRangeMax ? wantedMax + bucketSize : incrRoundDn(wantedMax, bucketSize);\n\n          return [wantedMin, wantedMax];\n        },\n  });\n\n  builder.addScale({\n    scaleKey: 'y', // counts\n    isTime: false,\n    distribution: ScaleDistribution.Linear,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n    softMin: 0,\n  });\n\n  const fmt = frame.fields[0].display!;\n  const xAxisFormatter = (v: number) => {\n    return formattedValueToString(fmt(v));\n  };\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: AxisPlacement.Bottom,\n    incrs: isOrdinalX ? [1] : useLogScale ? undefined : histogramBucketSizes,\n    splits: useLogScale || isOrdinalX ? undefined : xSplits,\n    values: isOrdinalX\n      ? (u, splits) => splits\n      : (u, splits) => {\n          const tickLabels = splits.map(xAxisFormatter);\n\n          const maxWidth = tickLabels.reduce(\n            (curMax, label) => Math.max(measureText(label, UPLOT_AXIS_FONT_SIZE).width, curMax),\n            0\n          );\n\n          const labelSpacing = 10;\n          const maxCount = u.bbox.width / ((maxWidth + labelSpacing) * devicePixelRatio);\n          const keepMod = Math.ceil(tickLabels.length / maxCount);\n\n          return tickLabels.map((label, i) => (i % keepMod === 0 ? label : null));\n        },\n    //incrs: () => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((mult) => mult * bucketSize),\n    //splits: config.xSplits,\n    //values: config.xValues,\n    //grid: false,\n    //ticks: false,\n    //gap: 15,\n    theme,\n  });\n\n  // assumes BucketMax is [1]\n  let countField = frame.fields[2];\n  let dispY = countField.display;\n\n  builder.addAxis({\n    scaleKey: 'y',\n    isTime: false,\n    placement: AxisPlacement.Left,\n    formatValue: (v, decimals) => formattedValueToString(dispY!(v, decimals)),\n    //splits: config.xSplits,\n    //values: config.xValues,\n    //grid: false,\n    //ticks: false,\n    //gap: 15,\n    theme,\n  });\n\n  builder.setCursor({\n    points: { show: false },\n    drag: {\n      x: true,\n      y: false,\n      setScale: true,\n    },\n    dataIdx: (u, _, closestIdx, xValue) =>\n      isOrdinalX ? Math.floor(xValue) : xValue < u.data[0][closestIdx] ? closestIdx - 1 : closestIdx,\n    focus: {\n      prox: 1e6,\n      bias: 1,\n    },\n  });\n\n  let stackingGroups = getStackingGroups(xMinOnlyFrame(frame));\n  builder.setStackingGroups(stackingGroups);\n\n  let pathBuilder = uPlot.paths.bars!({ align: 1, size: [1, Infinity] });\n\n  let seriesIndex = 0;\n\n  // assumes xMin is [0], xMax is [1]\n  for (let i = 2; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    field.state = field.state ?? {};\n    field.state.seriesIndex = seriesIndex++;\n\n    const customConfig: FieldConfig = { ...defaultFieldConfig, ...field.config.custom };\n\n    const scaleKey = 'y';\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    builder.addSeries({\n      scaleKey,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      //lineStyle: customConfig.lineStyle,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder,\n      //pointsBuilder: config.drawPoints,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state.origin,\n    });\n  }\n\n  return builder;\n};\n\n// since we're reusing timeseries prep for stacking, we need to make a tmp frame where fields match the uplot data\n// by removing the x bucket max field to make sure stacking group series idxs match up\nconst xMinOnlyFrame = (frame: DataFrame) => ({\n  ...frame,\n  fields: frame.fields.filter((f) => f.name !== histogramFrameBucketMaxFieldName),\n});\n\nconst preparePlotData = (builder: UPlotConfigBuilder, xMinOnlyFrame: DataFrame) => {\n  // uPlot's bars pathBuilder will draw rects even if 0 (to distinguish them from nulls)\n  // but for histograms we want to omit them, so remap 0s -> nulls\n  for (let i = 1; i < xMinOnlyFrame.fields.length; i++) {\n    let counts = xMinOnlyFrame.fields[i].values;\n\n    for (let j = 0; j < counts.length; j++) {\n      if (counts[j] === 0) {\n        counts[j] = null; // mutates!\n      }\n    }\n  }\n\n  return preparePlotData2(xMinOnlyFrame, builder.getStackingGroups());\n};\n\ninterface State {\n  alignedData: AlignedData;\n  alignedFrame: DataFrame;\n  config?: UPlotConfigBuilder;\n  xMinOnlyFrame: DataFrame;\n}\n\nexport class Histogram extends React.Component<HistogramProps, State> {\n  constructor(props: HistogramProps) {\n    super(props);\n    this.state = this.prepState(props);\n  }\n\n  prepState(props: HistogramProps, withConfig = true): State {\n    const { alignedFrame } = props;\n\n    const config = withConfig ? prepConfig(alignedFrame, this.props.theme) : this.state.config!;\n    const xMinOnly = xMinOnlyFrame(alignedFrame);\n    const alignedData = preparePlotData(config, xMinOnly);\n\n    return {\n      alignedFrame,\n      alignedData,\n      config,\n      xMinOnlyFrame: xMinOnly,\n    };\n  }\n\n  renderLegend(config: UPlotConfigBuilder) {\n    const { legend } = this.props;\n\n    if (!config || legend.showLegend === false) {\n      return null;\n    }\n\n    const frames = this.props.options.combine ? [this.props.alignedFrame] : this.props.rawSeries!;\n\n    return <PlotLegend data={frames} config={config} maxHeight=\"35%\" maxWidth=\"60%\" {...legend} />;\n  }\n\n  componentDidUpdate(prevProps: HistogramProps) {\n    const { structureRev, alignedFrame, bucketSize, bucketCount } = this.props;\n\n    if (alignedFrame !== prevProps.alignedFrame) {\n      const shouldReconfig =\n        this.state.config == null ||\n        bucketCount !== prevProps.bucketCount ||\n        bucketSize !== prevProps.bucketSize ||\n        this.props.options !== prevProps.options ||\n        this.state.config === undefined ||\n        structureRev !== prevProps.structureRev ||\n        !structureRev;\n\n      const newState = this.prepState(this.props, shouldReconfig);\n\n      this.setState(newState);\n    }\n  }\n\n  render() {\n    const { width, height, children, alignedFrame } = this.props;\n    const { config } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return (\n      <VizLayout width={width} height={height} legend={this.renderLegend(config)}>\n        {(vizWidth: number, vizHeight: number) => (\n          <UPlotChart config={this.state.config!} data={this.state.alignedData} width={vizWidth} height={vizHeight}>\n            {children ? children(config, alignedFrame, this.state.xMinOnlyFrame) : null}\n          </UPlotChart>\n        )}\n      </VizLayout>\n    );\n  }\n}\n","import { ReactNode, useMemo } from 'react';\n\nimport { DataFrame, formattedValueToString } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport {\n  VizTooltipContent,\n  VizTooltipFooter,\n  VizTooltipHeader,\n  VizTooltipWrapper,\n  getContentItems,\n  VizTooltipItem,\n} from '@grafana/ui/internal';\n\nimport { getDataLinks } from '../status-history/utils';\nimport { isTooltipScrollable } from '../timeseries/utils';\n\nexport interface HistogramTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n  xMinOnlyFrame: DataFrame;\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n  maxHeight?: number;\n}\n\nexport const HistogramTooltip = ({\n  series,\n  xMinOnlyFrame,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  maxHeight,\n}: HistogramTooltipProps) => {\n  const xMinField = series.fields[0];\n  const xMaxField = series.fields[1];\n\n  // use the formatter from other bucket bound if none is defined\n  const { display: xMinDisp } = xMinField.config.unit != null ? xMinField : xMaxField;\n  const { display: xMaxDisp } = xMaxField.config.unit != null ? xMaxField : xMinField;\n\n  const xMinVal = formattedValueToString(xMinDisp!(xMinField.values[dataIdxs[0]!]));\n  const xMaxVal = formattedValueToString(xMaxDisp!(xMaxField.values[dataIdxs[1]!]));\n\n  const headerItem: VizTooltipItem = {\n    label: 'Bucket',\n    value: `${xMinVal} - ${xMaxVal}`,\n  };\n\n  const contentItems = useMemo(\n    () => getContentItems(xMinOnlyFrame.fields, xMinField, dataIdxs, seriesIdx, mode, sortOrder),\n    [xMinOnlyFrame.fields, xMinField, dataIdxs, seriesIdx, mode, sortOrder]\n  );\n\n  let footer: ReactNode;\n\n  if (isPinned && seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const dataIdx = dataIdxs[seriesIdx]!;\n    const links = getDataLinks(field, dataIdx);\n\n    footer = <VizTooltipFooter dataLinks={links} />;\n  }\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n","import { useMemo } from 'react';\n\nimport {\n  histogramFieldsToFrame,\n  joinHistograms,\n  DataFrameType,\n  PanelProps,\n  buildHistogram,\n  cacheFieldDisplayNames,\n  getHistogramFields,\n} from '@grafana/data';\nimport { Trans } from '@grafana/i18n';\nimport { TooltipDisplayMode, TooltipPlugin2, useTheme2 } from '@grafana/ui';\nimport { TooltipHoverMode } from '@grafana/ui/internal';\n\nimport { Histogram, getBucketSize } from './Histogram';\nimport { HistogramTooltip } from './HistogramTooltip';\nimport { Options } from './panelcfg.gen';\n\ntype Props = PanelProps<Options>;\n\nexport const HistogramPanel = ({ data, options, width, height }: Props) => {\n  const theme = useTheme2();\n\n  const histogram = useMemo(() => {\n    if (!data.series.length) {\n      return undefined;\n    }\n\n    // stamp origins for legend's calcs (from raw values)\n    data.series.forEach((frame, frameIndex) => {\n      frame.fields.forEach((field, fieldIndex) => {\n        field.state = {\n          ...field.state,\n          origin: {\n            frameIndex,\n            fieldIndex,\n          },\n        };\n      });\n    });\n\n    cacheFieldDisplayNames(data.series);\n\n    if (\n      data.series.length === 1 ||\n      data.series.every(\n        (frame) => frame.meta?.type === DataFrameType.HeatmapCells || frame.meta?.type === DataFrameType.HeatmapRows\n      )\n    ) {\n      const histograms = data.series.map((frame) => getHistogramFields(frame)).filter((hist) => hist != null);\n\n      if (histograms.length) {\n        return histogramFieldsToFrame(joinHistograms(histograms), theme);\n      }\n    }\n    const hist = buildHistogram(data.series, options, theme);\n    if (!hist) {\n      return undefined;\n    }\n\n    return histogramFieldsToFrame(hist, theme);\n  }, [data.series, options, theme]);\n\n  if (!histogram || !histogram.fields.length) {\n    return (\n      <div className=\"panel-empty\">\n        <p>\n          <Trans i18nKey=\"histogram.histogram-panel.no-histogram-found-in-response\">\n            No histogram found in response\n          </Trans>\n        </p>\n      </div>\n    );\n  }\n\n  const bucketSize = getBucketSize(histogram);\n\n  return (\n    <Histogram\n      options={options}\n      theme={theme}\n      legend={options.legend}\n      rawSeries={data.series}\n      structureRev={data.structureRev}\n      width={width}\n      height={height}\n      alignedFrame={histogram}\n      bucketSize={bucketSize}\n      bucketCount={options.bucketCount}\n    >\n      {(builder, alignedFrame, xMinOnlyFrame) => {\n        return (\n          <>\n            {options.tooltip.mode !== TooltipDisplayMode.None && (\n              <TooltipPlugin2\n                config={builder}\n                hoverMode={\n                  options.tooltip.mode === TooltipDisplayMode.Single ? TooltipHoverMode.xOne : TooltipHoverMode.xAll\n                }\n                render={(u, dataIdxs, seriesIdx, isPinned = false) => {\n                  return (\n                    <HistogramTooltip\n                      series={histogram}\n                      xMinOnlyFrame={xMinOnlyFrame}\n                      dataIdxs={dataIdxs}\n                      seriesIdx={seriesIdx}\n                      mode={options.tooltip.mode}\n                      sortOrder={options.tooltip.sort}\n                      isPinned={isPinned}\n                      maxHeight={options.tooltip.maxHeight}\n                    />\n                  );\n                }}\n                maxWidth={options.tooltip.maxWidth}\n              />\n            )}\n          </>\n        );\n      }}\n    </Histogram>\n  );\n};\n","import { StackingMode } from '@grafana/schema';\n\nimport { FieldConfig } from './panelcfg.gen';\n\nexport const defaultHistogramConfig: FieldConfig = {\n  stacking: {\n    mode: StackingMode.None,\n    group: 'A',\n  },\n};\n","import { isNil, omitBy } from 'lodash';\n\nimport { FieldConfigSource, PanelTypeChangedHandler } from '@grafana/data';\nimport {\n  LegendDisplayMode,\n  SortOrder,\n  StackingMode,\n  TooltipDisplayMode,\n} from '@grafana/schema/dist/esm/common/common.gen';\n\nimport { defaultHistogramConfig } from './config';\nimport { FieldConfig as HistogramFieldConfig, Options } from './panelcfg.gen';\n\n/*\n * This is called when the panel changes from another panel\n */\nexport const changeToHistogramPanelMigrationHandler: PanelTypeChangedHandler = (\n  panel,\n  prevPluginId,\n  prevOptions,\n  prevFieldConfig\n) => {\n  if (prevPluginId === 'graph') {\n    const graphOptions: GraphOptions = prevOptions.angular;\n\n    if (graphOptions.xaxis?.mode === 'histogram') {\n      const { fieldConfig, options } = graphToHistogramOptions({\n        ...prevOptions.angular,\n        fieldConfig: prevFieldConfig,\n      });\n\n      panel.fieldConfig = fieldConfig; // Mutates the incoming panel\n\n      return options;\n    }\n  }\n\n  return {};\n};\n\nfunction graphToHistogramOptions(graphOptions: GraphOptions): {\n  fieldConfig: FieldConfigSource;\n  options: Options;\n} {\n  let histogramFieldConfig: HistogramFieldConfig = {};\n  const options: Options = {\n    legend: {\n      displayMode: LegendDisplayMode.List,\n      showLegend: true,\n      placement: 'bottom',\n      calcs: [],\n    },\n    tooltip: {\n      mode: TooltipDisplayMode.Single,\n      sort: SortOrder.None,\n    },\n    combine: false,\n  };\n\n  if (graphOptions.stack) {\n    histogramFieldConfig.stacking = {\n      mode: graphOptions.percentage ? StackingMode.Percent : StackingMode.Normal,\n      group: defaultHistogramConfig.stacking!.group,\n    };\n\n    options.combine = false;\n  }\n\n  return {\n    fieldConfig: {\n      defaults: omitBy(\n        {\n          custom: histogramFieldConfig,\n        },\n        isNil\n      ),\n      overrides: [],\n    },\n    options,\n  };\n}\n\ninterface GraphOptions {\n  stack?: boolean;\n  percentage?: boolean;\n  xaxis: {\n    mode: 'series' | 'time' | 'histogram';\n    values?: string[];\n  };\n}\n","import {\n  isHistogramFrameBucketMinFieldName,\n  isHistogramFrameBucketMaxFieldName,\n  DataFrame,\n  FieldType,\n} from '@grafana/data';\n\nexport function originalDataHasHistogram(frames?: DataFrame[]): boolean {\n  if (frames?.length !== 1) {\n    return false;\n  }\n  const frame = frames[0];\n  if (frame.fields.length < 3) {\n    return false;\n  }\n\n  if (\n    !isHistogramFrameBucketMinFieldName(frame.fields[0].name) ||\n    !isHistogramFrameBucketMaxFieldName(frame.fields[1].name)\n  ) {\n    return false;\n  }\n  for (const field of frame.fields) {\n    if (field.type !== FieldType.number) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {\n  FieldColorModeId,\n  FieldConfigProperty,\n  FieldType,\n  identityOverrideProcessor,\n  PanelPlugin,\n  histogramFieldInfo,\n} from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { commonOptionsBuilder, getGraphFieldOptions } from '@grafana/ui';\nimport { StackingEditor } from '@grafana/ui/internal';\n\nimport { HistogramPanel } from './HistogramPanel';\nimport { defaultHistogramConfig } from './config';\nimport { changeToHistogramPanelMigrationHandler } from './migrations';\nimport { FieldConfig, Options, defaultFieldConfig, defaultOptions } from './panelcfg.gen';\nimport { originalDataHasHistogram } from './utils';\n\nexport const plugin = new PanelPlugin<Options, FieldConfig>(HistogramPanel)\n  .setPanelChangeHandler(changeToHistogramPanelMigrationHandler)\n  .setPanelOptions((builder) => {\n    const category = [t('histogram.category-histogram', 'Histogram')];\n    builder\n      .addCustomEditor({\n        id: '__calc__',\n        path: '__calc__',\n        name: 'Values',\n        category,\n        description: 'Showing frequencies that are calculated in the query',\n        editor: () => null, // empty editor\n        showIf: (opts, data) => originalDataHasHistogram(data),\n      })\n      .addNumberInput({\n        path: 'bucketCount',\n        name: histogramFieldInfo.bucketCount.name,\n        category,\n        description: histogramFieldInfo.bucketCount.description,\n        settings: {\n          placeholder: `Default: ${defaultOptions.bucketCount}`,\n          min: 0,\n        },\n        showIf: (opts, data) => !originalDataHasHistogram(data),\n      })\n      .addNumberInput({\n        path: 'bucketSize',\n        name: histogramFieldInfo.bucketSize.name,\n        category,\n        description: histogramFieldInfo.bucketSize.description,\n        settings: {\n          placeholder: 'Auto',\n          min: 0,\n        },\n        defaultValue: defaultOptions.bucketSize,\n        showIf: (opts, data) => !originalDataHasHistogram(data),\n      })\n      .addNumberInput({\n        path: 'bucketOffset',\n        name: histogramFieldInfo.bucketOffset.name,\n        category,\n        description: histogramFieldInfo.bucketOffset.description,\n        settings: {\n          placeholder: `Default: ${defaultOptions.bucketOffset}`,\n          min: 0,\n        },\n        showIf: (opts, data) => !originalDataHasHistogram(data),\n      })\n      .addBooleanSwitch({\n        path: 'combine',\n        name: histogramFieldInfo.combine.name,\n        category,\n        description: histogramFieldInfo.combine.description,\n        defaultValue: defaultOptions.combine,\n        showIf: (opts, data) => !originalDataHasHistogram(data),\n      });\n\n    commonOptionsBuilder.addTooltipOptions(builder);\n    commonOptionsBuilder.addLegendOptions(builder);\n  })\n  .useFieldConfig({\n    standardOptions: {\n      [FieldConfigProperty.Color]: {\n        settings: {\n          byValueSupport: false,\n          bySeriesSupport: true,\n          preferThresholdsMode: false,\n        },\n        defaultValue: {\n          mode: FieldColorModeId.PaletteClassic,\n        },\n      },\n      [FieldConfigProperty.Links]: {\n        settings: {\n          showOneClick: true,\n        },\n      },\n    },\n    useCustomConfig: (builder) => {\n      const cfg = defaultFieldConfig;\n      const graphFieldOptions = getGraphFieldOptions();\n      const category = [t('histogram.category-histogram', 'Histogram')];\n\n      builder\n        .addCustomEditor({\n          id: 'stacking',\n          path: 'stacking',\n          name: t('histogram.name-stacking', 'Stacking'),\n          category,\n          defaultValue: defaultHistogramConfig.stacking,\n          editor: StackingEditor,\n          override: StackingEditor,\n          settings: {\n            options: graphFieldOptions.stacking,\n          },\n          process: identityOverrideProcessor,\n          shouldApply: (f) => f.type === FieldType.number,\n          showIf: (opts, data) => !originalDataHasHistogram(data),\n        })\n        .addSliderInput({\n          path: 'lineWidth',\n          name: t('histogram.name-line-width', 'Line width'),\n          category,\n          defaultValue: cfg.lineWidth,\n          settings: {\n            min: 0,\n            max: 10,\n            step: 1,\n          },\n        })\n        .addSliderInput({\n          path: 'fillOpacity',\n          name: t('histogram.name-fill-opacity', 'Fill opacity'),\n          category,\n          defaultValue: cfg.fillOpacity,\n          settings: {\n            min: 0,\n            max: 100,\n            step: 1,\n          },\n        })\n        .addRadio({\n          path: 'gradientMode',\n          name: t('histogram.name-gradient-mode', 'Gradient mode'),\n          category,\n          defaultValue: graphFieldOptions.fillGradient[0].value,\n          settings: {\n            options: graphFieldOptions.fillGradient,\n          },\n        });\n\n      commonOptionsBuilder.addHideFrom(builder);\n    },\n  });\n","import {\n  DataFrame,\n  Field,\n  FieldType,\n  getDisplayProcessor,\n  GrafanaTheme2,\n  isBooleanUnit,\n  TimeRange,\n  cacheFieldDisplayNames,\n  applyNullInsertThreshold,\n  nullToValue,\n} from '@grafana/data';\nimport { convertFieldType } from '@grafana/data/internal';\nimport { GraphFieldConfig, LineInterpolation, TooltipDisplayMode, VizTooltipOptions } from '@grafana/schema';\nimport { buildScaleKey } from '@grafana/ui/internal';\n\nimport { HeatmapTooltip } from '../heatmap/panelcfg.gen';\n\ntype ScaleKey = string;\n\n// this will re-enumerate all enum fields on the same scale to create one ordinal progression\n// e.g. ['a','b'][0,1,0] + ['c','d'][1,0,1] -> ['a','b'][0,1,0] + ['c','d'][3,2,3]\nfunction reEnumFields(frames: DataFrame[]): DataFrame[] {\n  let allTextsByKey: Map<ScaleKey, string[]> = new Map();\n\n  let frames2: DataFrame[] = frames.map((frame) => {\n    return {\n      ...frame,\n      fields: frame.fields.map((field) => {\n        if (field.type === FieldType.enum) {\n          let scaleKey = buildScaleKey(field.config, field.type);\n          let allTexts = allTextsByKey.get(scaleKey);\n\n          if (!allTexts) {\n            allTexts = [];\n            allTextsByKey.set(scaleKey, allTexts);\n          }\n\n          let idxs: number[] = field.values.toArray().slice();\n          let txts = field.config.type!.enum!.text!;\n\n          // by-reference incrementing\n          if (allTexts.length > 0) {\n            for (let i = 0; i < idxs.length; i++) {\n              idxs[i] += allTexts.length;\n            }\n          }\n\n          allTexts.push(...txts);\n\n          // shared among all enum fields on same scale\n          field.config.type!.enum!.text! = allTexts;\n\n          return {\n            ...field,\n            values: idxs,\n          };\n\n          // TODO: update displayProcessor?\n        }\n\n        return field;\n      }),\n    };\n  });\n\n  return frames2;\n}\n\n/**\n * Returns null if there are no graphable fields\n */\nexport function prepareGraphableFields(\n  series: DataFrame[],\n  theme: GrafanaTheme2,\n  timeRange?: TimeRange,\n  // numeric X requires a single frame where the first field is numeric\n  xNumFieldIdx?: number\n): DataFrame[] | null {\n  if (!series?.length) {\n    return null;\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let useNumericX = xNumFieldIdx != null;\n\n  // Make sure the numeric x field is first in the frame\n  if (xNumFieldIdx != null && xNumFieldIdx > 0) {\n    series = [\n      {\n        ...series[0],\n        fields: [series[0].fields[xNumFieldIdx], ...series[0].fields.filter((f, i) => i !== xNumFieldIdx)],\n      },\n    ];\n  }\n\n  // some datasources simply tag the field as time, but don't convert to milli epochs\n  // so we're stuck with doing the parsing here to avoid Moment slowness everywhere later\n  // this mutates (once)\n  for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.time && typeof field.values[0] !== 'number') {\n        field.values = convertFieldType(field, { destinationType: FieldType.time }).values;\n      }\n    }\n  }\n\n  let enumFieldsCount = 0;\n\n  loopy: for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.enum && ++enumFieldsCount > 1) {\n        series = reEnumFields(series);\n        break loopy;\n      }\n    }\n  }\n\n  let copy: Field;\n\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    const fields: Field[] = [];\n\n    let hasTimeField = false;\n    let hasValueField = false;\n\n    let nulledFrame = useNumericX\n      ? frame\n      : applyNullInsertThreshold({\n          frame,\n          refFieldPseudoMin: timeRange?.from.valueOf(),\n          refFieldPseudoMax: timeRange?.to.valueOf(),\n        });\n\n    const frameFields = nullToValue(nulledFrame).fields;\n\n    for (let fieldIdx = 0; fieldIdx < (frameFields?.length || 0); fieldIdx++) {\n      const field = frameFields[fieldIdx];\n\n      switch (field.type) {\n        case FieldType.time:\n          hasTimeField = true;\n          fields.push(field);\n          break;\n        case FieldType.number:\n          hasValueField = useNumericX ? fieldIdx > 0 : true;\n          copy = {\n            ...field,\n            values: field.values.map((v) => {\n              if (!(Number.isFinite(v) || v == null)) {\n                return null;\n              }\n              return v;\n            }),\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.enum:\n          hasValueField = true;\n        case FieldType.string:\n          copy = {\n            ...field,\n            values: field.values,\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.boolean:\n          hasValueField = true;\n          const custom: GraphFieldConfig = field.config?.custom ?? {};\n          const config = {\n            ...field.config,\n            max: 1,\n            min: 0,\n            custom,\n          };\n\n          // smooth and linear do not make sense\n          if (custom.lineInterpolation !== LineInterpolation.StepBefore) {\n            custom.lineInterpolation = LineInterpolation.StepAfter;\n          }\n\n          copy = {\n            ...field,\n            config,\n            type: FieldType.number,\n            values: field.values.map((v) => {\n              if (v == null) {\n                return v;\n              }\n              return Boolean(v) ? 1 : 0;\n            }),\n          };\n\n          if (!isBooleanUnit(config.unit)) {\n            config.unit = 'bool';\n            copy.display = getDisplayProcessor({ field: copy, theme });\n          }\n\n          fields.push(copy);\n          break;\n      }\n    }\n\n    if ((useNumericX || hasTimeField) && hasValueField) {\n      frames.push({\n        ...frame,\n        length: nulledFrame.length,\n        fields,\n      });\n    }\n  }\n\n  if (frames.length) {\n    setClassicPaletteIdxs(frames, theme, 0);\n    matchEnumColorToSeriesColor(frames, theme);\n    return frames;\n  }\n\n  return null;\n}\n\nconst matchEnumColorToSeriesColor = (frames: DataFrame[], theme: GrafanaTheme2) => {\n  const { palette } = theme.visualization;\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type === FieldType.enum) {\n        const namedColor = palette[field.state?.seriesIndex! % palette.length];\n        const hexColor = theme.visualization.getColorByName(namedColor);\n        const enumConfig = field.config.type!.enum!;\n\n        enumConfig.color = Array(enumConfig.text!.length).fill(hexColor);\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    }\n  }\n};\n\nexport const setClassicPaletteIdxs = (frames: DataFrame[], theme: GrafanaTheme2, skipFieldIdx?: number) => {\n  let seriesIndex = 0;\n  frames.forEach((frame) => {\n    frame.fields.forEach((field, fieldIdx) => {\n      if (\n        fieldIdx !== skipFieldIdx &&\n        (field.type === FieldType.number || field.type === FieldType.boolean || field.type === FieldType.enum)\n      ) {\n        field.state = {\n          ...field.state,\n          seriesIndex: seriesIndex++, // TODO: skip this for fields with custom renderers (e.g. Candlestick)?\n        };\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    });\n  });\n};\n\nexport function getTimezones(timezones: string[] | undefined, defaultTimezone: string): string[] {\n  if (!timezones || !timezones.length) {\n    return [defaultTimezone];\n  }\n  return timezones.map((v) => (v?.length ? v : defaultTimezone));\n}\n\nexport const isTooltipScrollable = (tooltipOptions: VizTooltipOptions | HeatmapTooltip) => {\n  return tooltipOptions.mode === TooltipDisplayMode.Multi && tooltipOptions.maxHeight != null;\n};\n","import { css, cx } from '@emotion/css';\n\nimport { FALLBACK_COLOR, GrafanaTheme2 } from '@grafana/data';\nimport { LineStyle } from '@grafana/schema';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\nimport { SeriesIcon } from '../VizLegend/SeriesIcon';\n\nimport { ColorIndicator, DEFAULT_COLOR_INDICATOR } from './types';\nimport { getColorIndicatorClass } from './utils';\n\nexport enum ColorIndicatorPosition {\n  Leading,\n  Trailing,\n}\n\ninterface Props {\n  color?: string;\n  colorIndicator?: ColorIndicator;\n  position?: ColorIndicatorPosition;\n  lineStyle?: LineStyle;\n  isHollow?: boolean;\n}\n\nexport type ColorIndicatorStyles = ReturnType<typeof getStyles>;\n\nexport const VizTooltipColorIndicator = ({\n  color = FALLBACK_COLOR,\n  colorIndicator = DEFAULT_COLOR_INDICATOR,\n  position = ColorIndicatorPosition.Leading,\n  lineStyle,\n  isHollow,\n}: Props) => {\n  const styles = useStyles2(getStyles);\n\n  if (isHollow) {\n    return (\n      <div\n        style={{ border: `1px solid ${color}` }}\n        className={cx(\n          position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing,\n          getColorIndicatorClass(colorIndicator, styles)\n        )}\n      />\n    );\n  }\n\n  if (colorIndicator === ColorIndicator.series) {\n    return (\n      <SeriesIcon\n        color={color}\n        lineStyle={lineStyle}\n        className={position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing}\n      />\n    );\n  }\n\n  return (\n    <span\n      style={{ backgroundColor: color }}\n      className={cx(\n        position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing,\n        getColorIndicatorClass(colorIndicator, styles)\n      )}\n    />\n  );\n};\n\n// @TODO Update classes/add svgs\nconst getStyles = (theme: GrafanaTheme2) => ({\n  leading: css({\n    marginRight: theme.spacing(0.5),\n  }),\n  trailing: css({\n    marginLeft: theme.spacing(0.5),\n  }),\n  series: css({\n    width: '14px',\n    height: '4px',\n    borderRadius: theme.shape.radius.pill,\n    minWidth: '14px',\n  }),\n  value: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.default,\n    fontWeight: 500,\n    minWidth: '12px',\n  }),\n  hexagon: css({}),\n  pie_1_4: css({}),\n  pie_2_4: css({}),\n  pie_3_4: css({}),\n  marker_sm: css({\n    width: '4px',\n    height: '4px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '4px',\n  }),\n  marker_md: css({\n    width: '8px',\n    height: '8px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '8px',\n  }),\n  marker_lg: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '12px',\n  }),\n});\n","import { css, cx } from '@emotion/css';\nimport { CSSProperties, ReactNode, useEffect, useRef, useState } from 'react';\nimport * as React from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\nimport { InlineToast } from '../InlineToast/InlineToast';\nimport { Tooltip } from '../Tooltip/Tooltip';\n\nimport { ColorIndicatorPosition, VizTooltipColorIndicator } from './VizTooltipColorIndicator';\nimport { ColorPlacement, VizTooltipItem } from './types';\n\ninterface VizTooltipRowProps extends Omit<VizTooltipItem, 'value'> {\n  value: string | number | null | ReactNode;\n  justify?: string;\n  isActive?: boolean; // for series list\n  marginRight?: string;\n  isPinned: boolean;\n  showValueScroll?: boolean;\n  isHiddenFromViz?: boolean;\n}\n\nenum LabelValueTypes {\n  label = 'label',\n  value = 'value',\n}\n\nconst SUCCESSFULLY_COPIED_TEXT = 'Copied to clipboard';\nconst SHOW_SUCCESS_DURATION = 2 * 1000;\nconst HORIZONTAL_PX_PER_CHAR = 7;\n\nexport const VizTooltipRow = ({\n  label,\n  value,\n  color,\n  colorIndicator,\n  colorPlacement = ColorPlacement.first,\n  justify = 'flex-start',\n  isActive = false,\n  marginRight = '0px',\n  isPinned,\n  lineStyle,\n  showValueScroll,\n  isHiddenFromViz,\n}: VizTooltipRowProps) => {\n  const styles = useStyles2(getStyles, justify, marginRight);\n\n  const innerValueScrollStyle: CSSProperties = showValueScroll\n    ? {\n        maxHeight: 55,\n        whiteSpace: 'wrap',\n        wordBreak: 'break-word',\n        overflowY: 'auto',\n      }\n    : {\n        whiteSpace: 'pre-line',\n        wordBreak: 'break-word',\n        lineHeight: 1.2,\n      };\n\n  const [showLabelTooltip, setShowLabelTooltip] = useState(false);\n\n  const [copiedText, setCopiedText] = useState<Record<string, string> | null>(null);\n  const [showCopySuccess, setShowCopySuccess] = useState(false);\n\n  const labelRef = useRef<null | HTMLDivElement>(null);\n  const valueRef = useRef<null | HTMLDivElement>(null);\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n\n    if (showCopySuccess) {\n      timeoutId = setTimeout(() => {\n        setShowCopySuccess(false);\n      }, SHOW_SUCCESS_DURATION);\n    }\n\n    return () => {\n      window.clearTimeout(timeoutId);\n    };\n  }, [showCopySuccess]);\n\n  const copyToClipboard = async (text: string, type: LabelValueTypes) => {\n    if (!(navigator?.clipboard && window.isSecureContext)) {\n      fallbackCopyToClipboard(text, type);\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopiedText({ [`${type}`]: text });\n      setShowCopySuccess(true);\n    } catch (error) {\n      setCopiedText(null);\n    }\n  };\n\n  const fallbackCopyToClipboard = (text: string, type: LabelValueTypes) => {\n    // Use a fallback method for browsers/contexts that don't support the Clipboard API.\n    const textarea = document.createElement('textarea');\n    labelRef.current?.appendChild(textarea);\n    textarea.value = text;\n    textarea.focus();\n    textarea.select();\n    try {\n      const successful = document.execCommand('copy');\n      if (successful) {\n        setCopiedText({ [`${type}`]: text });\n        setShowCopySuccess(true);\n      }\n    } catch (err) {\n      console.error('Unable to copy to clipboard', err);\n    }\n\n    textarea.remove();\n  };\n\n  const onMouseEnterLabel = (event: React.MouseEvent<HTMLDivElement>) => {\n    if (event.currentTarget.offsetWidth < event.currentTarget.scrollWidth) {\n      setShowLabelTooltip(true);\n    }\n  };\n\n  const onMouseLeaveLabel = () => setShowLabelTooltip(false);\n\n  // if label is > 50% window width, try to put label/value pairs on new lines\n  if (label.length * HORIZONTAL_PX_PER_CHAR > window.innerWidth / 2) {\n    label = label.replaceAll('{', '{\\n  ').replaceAll('}', '\\n}').replaceAll(', ', ',\\n  ');\n  }\n\n  return (\n    <div className={styles.contentWrapper}>\n      {(color || label) && (\n        <div className={styles.valueWrapper}>\n          {color && colorPlacement === ColorPlacement.first && (\n            <VizTooltipColorIndicator\n              color={color}\n              colorIndicator={colorIndicator}\n              lineStyle={lineStyle}\n              isHollow={isHiddenFromViz}\n            />\n          )}\n          {!isPinned ? (\n            <div className={cx(styles.label, isActive && styles.activeSeries)}>{label}</div>\n          ) : (\n            <>\n              <Tooltip content={label} interactive={false} show={showLabelTooltip}>\n                <>\n                  {showCopySuccess && copiedText?.label && (\n                    <InlineToast placement=\"top\" referenceElement={labelRef.current}>\n                      {SUCCESSFULLY_COPIED_TEXT}\n                    </InlineToast>\n                  )}\n                  {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n                  <div\n                    className={cx(styles.label, isActive && styles.activeSeries, navigator?.clipboard && styles.copy)}\n                    onMouseEnter={onMouseEnterLabel}\n                    onMouseLeave={onMouseLeaveLabel}\n                    onClick={() => copyToClipboard(label, LabelValueTypes.label)}\n                    ref={labelRef}\n                  >\n                    {label}\n                  </div>\n                </>\n              </Tooltip>\n            </>\n          )}\n        </div>\n      )}\n\n      <div className={styles.valueWrapper}>\n        {color && colorPlacement === ColorPlacement.leading && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Leading}\n            lineStyle={lineStyle}\n          />\n        )}\n\n        {!isPinned ? (\n          <div className={cx(styles.value, isActive)} style={innerValueScrollStyle}>\n            {value}\n          </div>\n        ) : (\n          <>\n            {showCopySuccess && copiedText?.value && (\n              <InlineToast placement=\"top\" referenceElement={valueRef.current}>\n                {SUCCESSFULLY_COPIED_TEXT}\n              </InlineToast>\n            )}\n            {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n            <div\n              className={cx(styles.value, isActive, navigator?.clipboard && styles.copy)}\n              style={innerValueScrollStyle}\n              onClick={() => copyToClipboard(value ? value.toString() : '', LabelValueTypes.value)}\n              ref={valueRef}\n            >\n              {value}\n            </div>\n          </>\n        )}\n\n        {color && colorPlacement === ColorPlacement.trailing && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Trailing}\n            lineStyle={lineStyle}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2, justify: string, marginRight: string) => ({\n  contentWrapper: css({\n    display: 'flex',\n    alignItems: 'start',\n    justifyContent: justify,\n    marginRight: marginRight,\n  }),\n  label: css({\n    color: theme.colors.text.secondary,\n    fontWeight: 400,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    marginRight: theme.spacing(2),\n  }),\n  value: css({\n    fontWeight: 500,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n  }),\n  valueWrapper: css({\n    display: 'flex',\n    alignItems: 'center',\n  }),\n  activeSeries: css({\n    fontWeight: theme.typography.fontWeightBold,\n    color: theme.colors.text.maxContrast,\n  }),\n  copy: css({\n    cursor: 'pointer',\n  }),\n});\n"],"names":["getDataLinks","field","rowIdx","links","v","disp","linkLookup","link","key","getAllFrameActions","dataFrame","getFieldActions","replaceVars","rowIndex","actions","actionLookup","action","VizTooltipHeader","item","isPinned","styles","getStyles","label","value","color","colorIndicator","theme","VizTooltipContent","items","children","scrollable","maxHeight","scrollableStyle","colorPlacement","isActive","lineStyle","isHiddenFromViz","i","defaultOptions","defaultFieldConfig","incrRoundDn","num","incr","incrRoundUp","getBucketSize","frame","getBucketSize1","prepConfig","xScaleMin","xScaleMax","builder","UPlotConfigBuilder","isOrdinalX","bucketSize","bucketSize1","bucketFactor","useLogScale","xSplits","u","axisIdx","scaleMin","scaleMax","foundIncr","foundSpace","minSpace","bucketWidth","firstSplit","lastSplit","splits","skip","s","wantedMin","wantedMax","fullRangeMax","fmt","xAxisFormatter","tickLabels","maxWidth","curMax","measureText","maxCount","keepMod","dispY","decimals","_","closestIdx","xValue","stackingGroups","xMinOnlyFrame","pathBuilder","seriesIndex","customConfig","scaleKey","colorMode","seriesColor","f","preparePlotData","counts","j","Histogram","props","withConfig","alignedFrame","config","xMinOnly","alignedData","legend","frames","PlotLegend","prevProps","structureRev","bucketCount","shouldReconfig","newState","width","height","VizLayout","vizWidth","vizHeight","HistogramTooltip","series","dataIdxs","seriesIdx","mode","sortOrder","xMinField","xMaxField","xMinDisp","xMaxDisp","xMinVal","xMaxVal","headerItem","contentItems","footer","dataIdx","VizTooltipFooter","VizTooltipWrapper","HistogramPanel","data","options","histogram","frameIndex","fieldIndex","histograms","hist","TooltipPlugin2","defaultHistogramConfig","changeToHistogramPanelMigrationHandler","panel","prevPluginId","prevOptions","prevFieldConfig","fieldConfig","graphToHistogramOptions","graphOptions","histogramFieldConfig","originalDataHasHistogram","PanelPlugin","category","opts","cfg","graphFieldOptions","reEnumFields","allTextsByKey","allTexts","idxs","txts","prepareGraphableFields","timeRange","xNumFieldIdx","useNumericX","enumFieldsCount","loopy","copy","fields","hasTimeField","hasValueField","nulledFrame","frameFields","fieldIdx","custom","setClassicPaletteIdxs","matchEnumColorToSeriesColor","palette","namedColor","hexColor","enumConfig","skipFieldIdx","getTimezones","timezones","defaultTimezone","isTooltipScrollable","tooltipOptions","ColorIndicatorPosition","VizTooltipColorIndicator","position","isHollow","SeriesIcon","LabelValueTypes","SUCCESSFULLY_COPIED_TEXT","SHOW_SUCCESS_DURATION","HORIZONTAL_PX_PER_CHAR","VizTooltipRow","justify","marginRight","showValueScroll","innerValueScrollStyle","showLabelTooltip","setShowLabelTooltip","copiedText","setCopiedText","showCopySuccess","setShowCopySuccess","labelRef","valueRef","timeoutId","copyToClipboard","text","type","fallbackCopyToClipboard","textarea","err","onMouseEnterLabel","event","onMouseLeaveLabel","Tooltip","InlineToast"],"sourceRoot":""}