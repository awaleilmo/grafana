{"version":3,"file":"barChartPanel.67a9cab4162fa0a60382.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/status-history/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/BarChartLegend.tsx","webpack://grafana/./public/app/plugins/panel/barchart/bars.ts","webpack://grafana/./public/app/plugins/panel/barchart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/barchart/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/BarChartPanel.tsx","webpack://grafana/./public/app/plugins/panel/barchart/TickSpacingEditor.tsx","webpack://grafana/./public/app/plugins/panel/barchart/migrations.ts","webpack://grafana/./public/app/plugins/panel/barchart/suggestions.ts","webpack://grafana/./public/app/plugins/panel/barchart/module.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipHeader.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipContent.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/utils.ts","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipColorIndicator.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipRow.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/TimeSeriesTooltip.tsx"],"sourcesContent":["import { DataFrame, ActionModel, Field, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { getActions } from 'app/features/actions/utils';\n\nexport const getDataLinks = (field: Field, rowIdx: number) => {\n  const links: Array<LinkModel<Field>> = [];\n\n  if ((field.config.links?.length ?? 0) > 0 && field.getLinks != null) {\n    const v = field.values[rowIdx];\n    const disp = field.display ? field.display(v) : { text: `${v}`, numeric: +v };\n\n    const linkLookup = new Set<string>();\n\n    field.getLinks({ calculatedValue: disp, valueRowIndex: rowIdx }).forEach((link) => {\n      const key = `${link.title}/${link.href}`;\n      if (!linkLookup.has(key)) {\n        links.push(link);\n        linkLookup.add(key);\n      }\n    });\n  }\n\n  return links;\n};\n\nexport const getAllFrameActions = (dataFrame: DataFrame) => {};\n\nexport const getFieldActions = (\n  dataFrame: DataFrame,\n  field: Field,\n  replaceVars: InterpolateFunction,\n  rowIndex: number\n) => {\n  const actions: Array<ActionModel<Field>> = [];\n  const actionLookup = new Set<string>();\n\n  const actionsModel = getActions(dataFrame, field, field.state!.scopedVars!, replaceVars, field.config.actions ?? [], {\n    valueRowIndex: rowIndex,\n  });\n\n  actionsModel.forEach((action) => {\n    const key = `${action.title}`;\n    if (!actionLookup.has(key)) {\n      actions.push(action);\n      actionLookup.add(key);\n    }\n  });\n\n  return actions;\n};\n","import { includes } from 'lodash';\nimport { memo } from 'react';\n\nimport {\n  DataFrame,\n  Field,\n  FieldColorModeId,\n  getFieldSeriesColor,\n  ThresholdsConfig,\n  ThresholdsMode,\n  ValueMapping,\n} from '@grafana/data';\nimport { VizLegendOptions, AxisPlacement } from '@grafana/schema';\nimport { UPlotConfigBuilder, VizLayout, VizLayoutLegendProps, VizLegend, VizLegendItem, useTheme2 } from '@grafana/ui';\nimport { getDisplayValuesForCalcs } from '@grafana/ui/internal';\nimport { getThresholdItems, getValueMappingItems } from 'app/core/components/TimelineChart/utils';\ninterface BarChartLegend2Props extends VizLegendOptions, Omit<VizLayoutLegendProps, 'children'> {\n  data: DataFrame[];\n  colorField?: Field | null;\n  // config: UPlotConfigBuilder;\n}\n\n/**\n * mostly duplicates logic in PlotLegend below :(\n *\n * @internal\n */\nexport function hasVisibleLegendSeries(config: UPlotConfigBuilder, data: DataFrame[]) {\n  return data[0].fields.slice(1).some((field) => !Boolean(field.config.custom?.hideFrom?.legend));\n\n  // return config.getSeries().some((s, i) => {\n  //   const frameIndex = 0;\n  //   const fieldIndex = i + 1;\n  //   const field = data[frameIndex].fields[fieldIndex];\n  //   return !Boolean(field.config.custom?.hideFrom?.legend);\n  // });\n}\n\nexport const BarChartLegend = memo(\n  ({ data, placement, calcs, displayMode, colorField, ...vizLayoutLegendProps }: BarChartLegend2Props) => {\n    const theme = useTheme2();\n\n    const fieldConfig = data[0].fields[0].config;\n    const colorMode = fieldConfig.color?.mode;\n\n    const thresholdItems: VizLegendItem[] = [];\n    if (colorMode === FieldColorModeId.Thresholds) {\n      const thresholdsAbsolute: ThresholdsConfig = { mode: ThresholdsMode.Absolute, steps: [] };\n      const thresholdsPercent: ThresholdsConfig = { mode: ThresholdsMode.Percentage, steps: [] };\n\n      for (let i = 1; i < data[0].fields.length; i++) {\n        const field = data[0].fields[i];\n        // there is no reason to add threshold with only one (Base) step\n        if (field.config.thresholds && field.config.thresholds.steps.length > 1) {\n          if (field.config.thresholds.mode === ThresholdsMode.Absolute) {\n            for (const step of field.config.thresholds.steps) {\n              if (!includes(thresholdsAbsolute.steps, step)) {\n                thresholdsAbsolute.steps.push(step);\n              }\n            }\n          } else {\n            for (const step of field.config.thresholds.steps) {\n              if (!includes(thresholdsPercent.steps, step)) {\n                thresholdsPercent.steps.push(step);\n              }\n            }\n          }\n        }\n      }\n\n      const thresholdAbsoluteItems: VizLegendItem[] = getThresholdItems(fieldConfig, theme, thresholdsAbsolute);\n      const thresholdPercentItems: VizLegendItem[] = getThresholdItems(fieldConfig, theme, thresholdsPercent);\n      thresholdItems.push(...thresholdAbsoluteItems, ...thresholdPercentItems);\n    }\n\n    const valueMappings: ValueMapping[] = [];\n    for (let i = 1; i < data[0].fields.length; i++) {\n      const mappings = data[0].fields[i].config.mappings;\n      if (mappings) {\n        for (const mapping of mappings) {\n          if (!includes(valueMappings, mapping)) {\n            valueMappings.push(mapping);\n          }\n        }\n      }\n    }\n    const valueMappingItems: VizLegendItem[] = getValueMappingItems(valueMappings, theme);\n\n    const legendItems = data[0].fields\n      .slice(1)\n      .map((field, i) => {\n        const frameIndex = 0;\n        const fieldIndex = i + 1;\n        // const axisPlacement = config.getAxisPlacement(s.props.scaleKey); // TODO: this should be stamped on the field.config?\n        // const field = data[frameIndex].fields[fieldIndex];\n\n        if (!field || field.config.custom?.hideFrom?.legend) {\n          return undefined;\n        }\n\n        // // apparently doing a second pass like this will take existing state.displayName, and if same as another one, appends counter\n        // const label = getFieldDisplayName(field, data[0], data);\n        const label = field.state?.displayName ?? field.name;\n\n        const color = getFieldSeriesColor(field, theme).color;\n\n        const item: VizLegendItem = {\n          disabled: field.state?.hideFrom?.viz,\n          color,\n          label,\n          yAxis: field.config.custom?.axisPlacement === AxisPlacement.Right ? 2 : 1,\n          getDisplayValues: () => getDisplayValuesForCalcs(calcs, field, theme),\n          getItemKey: () => `${label}-${frameIndex}-${fieldIndex}`,\n        };\n\n        return item;\n      })\n      .filter((i): i is VizLegendItem => i !== undefined);\n\n    return (\n      <VizLayout.Legend placement={placement} {...vizLayoutLegendProps}>\n        <VizLegend\n          placement={placement}\n          items={legendItems}\n          thresholdItems={thresholdItems}\n          mappingItems={valueMappingItems}\n          displayMode={displayMode}\n          sortBy={vizLayoutLegendProps.sortBy}\n          sortDesc={vizLayoutLegendProps.sortDesc}\n          isSortable={true}\n        />\n      </VizLayout.Legend>\n    );\n  }\n);\n\nBarChartLegend.displayName = 'BarChartLegend';\n","import uPlot, { Axis, AlignedData, Scale } from 'uplot';\n\nimport { colorManipulator, DataFrame, dateTimeFormat, GrafanaTheme2, systemDateFormats, TimeZone } from '@grafana/data';\nimport {\n  StackingMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  VizTextDisplayOptions,\n  VizLegendOptions,\n} from '@grafana/schema';\nimport { measureText } from '@grafana/ui';\nimport { timeUnitSize, StackingGroup, preparePlotData2 } from '@grafana/ui/internal';\n\nconst intervals = systemDateFormats.interval;\n\nimport { distribute, SPACE_BETWEEN } from './distribute';\nimport { findRects, intersects, pointWithin, Quadtree, Rect } from './quadtree';\n\nconst groupDistr = SPACE_BETWEEN;\nconst barDistr = SPACE_BETWEEN;\n// min.max font size for value label\nconst VALUE_MIN_FONT_SIZE = 8;\nconst VALUE_MAX_FONT_SIZE = 30;\n// % of width/height of the bar that value should fit in when measuring size\nconst BAR_FONT_SIZE_RATIO = 0.65;\n// distance between label and a bar in % of bar width\nconst LABEL_OFFSET_FACTOR_VT = 0.1;\nconst LABEL_OFFSET_FACTOR_HZ = 0.15;\n// max distance\nconst LABEL_OFFSET_MAX_VT = 5;\nconst LABEL_OFFSET_MAX_HZ = 10;\n\n// text baseline middle runs through the middle of lowercase letters\n// since bar values are numbers and uppercase-like, we want the middle of uppercase\n// this is a cheap fudge factor that skips expensive and inconsistent cross-browser measuring\nconst MIDDLE_BASELINE_SHIFT = 0.1;\n\n/**\n * @internal\n */\nexport interface BarsOptions {\n  xOri: ScaleOrientation;\n  xDir: ScaleDirection;\n  groupWidth: number;\n  barWidth: number;\n  barRadius: number;\n  showValue: VisibilityMode;\n  stacking: StackingMode;\n  rawValue: (seriesIdx: number, valueIdx: number) => number | null;\n  getColor?: (seriesIdx: number, valueIdx: number, value: unknown) => string | null;\n  fillOpacity?: number;\n  formatValue: (seriesIdx: number, value: unknown) => string;\n  formatShortValue: (seriesIdx: number, value: unknown) => string;\n  timeZone?: TimeZone;\n  text?: VizTextDisplayOptions;\n  hoverMulti?: boolean;\n  legend?: VizLegendOptions;\n  xSpacing?: number;\n  xTimeAuto?: boolean;\n  negY?: boolean[];\n  fullHighlight?: boolean;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelTable {\n  [index: number]: ValueLabelArray;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelArray {\n  [index: number]: ValueLabel;\n}\n\n/**\n * @internal\n */\ninterface ValueLabel {\n  text: string;\n  value: number | null;\n  hidden: boolean;\n  bbox?: Rect;\n  textMetrics?: TextMetrics;\n  x?: number;\n  y?: number;\n}\n\n/**\n * @internal\n */\nfunction calculateFontSizeWithMetrics(\n  text: string,\n  width: number,\n  height: number,\n  lineHeight: number,\n  maxSize?: number\n) {\n  // calculate width in 14px\n  const textSize = measureText(text, 14);\n  // how much bigger than 14px can we make it while staying within our width constraints\n  const fontSizeBasedOnWidth = (width / (textSize.width + 2)) * 14;\n  const fontSizeBasedOnHeight = height / lineHeight;\n\n  // final fontSize\n  const optimalSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);\n  return {\n    fontSize: Math.min(optimalSize, maxSize ?? optimalSize),\n    textMetrics: textSize,\n  };\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: BarsOptions, theme: GrafanaTheme2) {\n  const {\n    xOri,\n    xDir: dir,\n    rawValue,\n    getColor,\n    formatValue,\n    formatShortValue,\n    fillOpacity = 1,\n    showValue,\n    xSpacing = 0,\n    hoverMulti = false,\n    timeZone = 'browser',\n  } = opts;\n  const isXHorizontal = xOri === ScaleOrientation.Horizontal;\n  const hasAutoValueSize = !Boolean(opts.text?.valueSize);\n  const isStacked = opts.stacking !== StackingMode.None;\n  const pctStacked = opts.stacking === StackingMode.Percent;\n\n  let { groupWidth, barWidth, barRadius = 0 } = opts;\n\n  if (isStacked) {\n    [groupWidth, barWidth] = [barWidth, groupWidth];\n  }\n\n  let qt: Quadtree;\n  const numSeries = 30; // !!\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n  let hRect: Rect | null;\n\n  // for distr: 2 scales, the splits array should contain indices into data[0] rather than values\n  const xSplits: Axis.Splits | undefined = (u) => Array.from(u.data[0].map((v, i) => i));\n\n  const hFilter: Axis.Filter | undefined =\n    xSpacing === 0\n      ? undefined\n      : (u, splits) => {\n          // hSpacing?\n          const dim = u.bbox.width;\n          const _dir = dir * (isXHorizontal ? 1 : -1);\n\n          let dataLen = splits.length;\n          let lastIdx = dataLen - 1;\n\n          let skipMod = 0;\n\n          let cssDim = dim / uPlot.pxRatio;\n          let maxTicks = Math.abs(Math.floor(cssDim / xSpacing));\n\n          skipMod = dataLen < maxTicks ? 0 : Math.ceil(dataLen / maxTicks);\n\n          let splits2 = splits.map((v, i) => {\n            let shouldSkip = skipMod !== 0 && (xSpacing > 0 ? i : lastIdx - i) % skipMod > 0;\n            return shouldSkip ? null : v;\n          });\n\n          return _dir === 1 ? splits2 : splits2.reverse();\n        };\n\n  // the splits passed into here are data[0] values looked up by the indices returned from splits()\n  const xValues: Axis.Values = (u, splits, axisIdx, foundSpace, foundIncr) => {\n    if (opts.xTimeAuto) {\n      let format = intervals.year;\n\n      if (foundIncr < timeUnitSize.second) {\n        format = intervals.millisecond;\n      } else if (foundIncr < timeUnitSize.minute) {\n        format = intervals.second;\n      } else if (foundIncr < timeUnitSize.hour) {\n        format = intervals.minute;\n      } else if (foundIncr < timeUnitSize.day) {\n        format = intervals.hour;\n      } else if (foundIncr < timeUnitSize.month) {\n        format = intervals.day;\n      } else if (foundIncr < timeUnitSize.year) {\n        format = intervals.month;\n      } else {\n        format = intervals.year;\n      }\n\n      return splits.map((v) => (v == null ? '' : dateTimeFormat(v, { format, timeZone })));\n    }\n\n    return splits.map((v) => (isXHorizontal ? formatShortValue(0, v) : formatValue(0, v)));\n  };\n\n  // this expands the distr: 2 scale so that the indicies of each data[0] land at the proper justified positions\n  const xRange: Scale.Range = (u, min, max) => {\n    min = 0;\n    max = Math.max(1, u.data[0].length - 1);\n\n    let pctOffset = 0;\n\n    // how far in is the first tick in % of full dimension\n    distribute(u.data[0].length, groupWidth, groupDistr, 0, (di, lftPct, widPct) => {\n      pctOffset = lftPct + widPct / 2;\n    });\n\n    // expand scale range by equal amounts on both ends\n    let rn = max - min;\n\n    if (pctOffset === 0.5) {\n      min -= rn;\n    } else {\n      let upScale = 1 / (1 - pctOffset * 2);\n      let offset = (upScale * rn - rn) / 2;\n\n      min -= offset;\n      max += offset;\n    }\n\n    return [min, max];\n  };\n\n  let distrTwo = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct + groupDimPct * barOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct * barDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  let distrOne = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  const LABEL_OFFSET_FACTOR = isXHorizontal ? LABEL_OFFSET_FACTOR_VT : LABEL_OFFSET_FACTOR_HZ;\n  const LABEL_OFFSET_MAX = isXHorizontal ? LABEL_OFFSET_MAX_VT : LABEL_OFFSET_MAX_HZ;\n\n  let barsPctLayout: Array<null | { offs: number[]; size: number[] }> = [];\n  let barsColors: Array<null | { fill: Array<string | null>; stroke: Array<string | null> }> = [];\n  let scaleFactor = 1;\n  let labels: ValueLabelTable;\n  let fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n  let labelOffset = LABEL_OFFSET_MAX;\n\n  // minimum available space for labels between bar end and plotting area bound (in canvas pixels)\n  let vSpace = Infinity;\n  let hSpace = Infinity;\n\n  let useMappedColors = getColor != null;\n\n  let mappedColorDisp = useMappedColors\n    ? {\n        fill: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.fill,\n        },\n        stroke: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.stroke,\n        },\n      }\n    : {};\n\n  let barsBuilder = uPlot.paths.bars!({\n    radius: pctStacked\n      ? 0\n      : !isStacked\n        ? barRadius\n        : (u: uPlot, seriesIdx: number) => {\n            let isTopmostSeries = seriesIdx === u.data.length - 1;\n            return isTopmostSeries ? [barRadius, 0] : [0, 0];\n          },\n    disp: {\n      x0: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.offs,\n      },\n      size: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.size,\n      },\n      ...mappedColorDisp,\n    },\n    // collect rendered bar geometry\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding)\n      // translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n\n      let val = u.data[seriesIdx][dataIdx]!;\n      // accum min space abvailable for labels\n      if (isXHorizontal) {\n        vSpace = Math.min(vSpace, val < 0 ? u.bbox.height - (top + hgt) : top);\n        hSpace = wid;\n      } else {\n        vSpace = hgt;\n        hSpace = Math.min(hSpace, val < 0 ? lft : u.bbox.width - (lft + wid));\n      }\n\n      let barRect = { x: lft, y: top, w: wid, h: hgt, sidx: seriesIdx, didx: dataIdx };\n\n      if (!isStacked && opts.fullHighlight) {\n        if (opts.xOri === ScaleOrientation.Horizontal) {\n          barRect.y = 0;\n          barRect.h = u.bbox.height;\n        } else {\n          barRect.x = 0;\n          barRect.w = u.bbox.width;\n        }\n      }\n\n      qt.add(barRect);\n\n      if (showValue !== VisibilityMode.Never) {\n        const raw = rawValue(seriesIdx, dataIdx)!;\n        let divider = 1;\n\n        if (pctStacked && alignedTotals![seriesIdx][dataIdx]!) {\n          divider = alignedTotals![seriesIdx][dataIdx]!;\n        }\n\n        const v = divider === 0 ? 0 : raw / divider;\n        // Format Values and calculate label offsets\n        const text = formatValue(seriesIdx, v);\n        labelOffset = Math.min(labelOffset, Math.round(LABEL_OFFSET_FACTOR * (isXHorizontal ? wid : hgt)));\n\n        if (labels[dataIdx] === undefined) {\n          labels[dataIdx] = {};\n        }\n        labels[dataIdx][seriesIdx] = { text: text, value: rawValue(seriesIdx, dataIdx), hidden: false };\n\n        // Calculate font size when it's set to be automatic\n        if (hasAutoValueSize) {\n          const { fontSize: calculatedSize, textMetrics } = calculateFontSizeWithMetrics(\n            labels[dataIdx][seriesIdx].text,\n            hSpace * (isXHorizontal ? BAR_FONT_SIZE_RATIO : 1) - (isXHorizontal ? 0 : labelOffset),\n            vSpace * (isXHorizontal ? 1 : BAR_FONT_SIZE_RATIO) - (isXHorizontal ? labelOffset : 0),\n            1\n          );\n\n          // Save text metrics\n          labels[dataIdx][seriesIdx].textMetrics = textMetrics;\n\n          // Retrieve the new font size and use it\n          let autoFontSize = Math.round(Math.min(fontSize, VALUE_MAX_FONT_SIZE, calculatedSize));\n\n          // Calculate the scaling factor for bouding boxes\n          // Take into account the fact that calculateFontSize\n          // uses 14px measurement so we need to adjust the scale factor\n          scaleFactor = (autoFontSize / fontSize) * (autoFontSize / 14);\n\n          // Update the end font-size\n          fontSize = autoFontSize;\n        } else {\n          labels[dataIdx][seriesIdx].textMetrics = measureText(labels[dataIdx][seriesIdx].text, fontSize);\n        }\n\n        let middleShift = isXHorizontal ? 0 : -Math.round(MIDDLE_BASELINE_SHIFT * fontSize);\n        let value = rawValue(seriesIdx, dataIdx);\n\n        if (opts.negY?.[seriesIdx] && value != null) {\n          value *= -1;\n        }\n\n        if (value != null) {\n          // Calculate final co-ordinates for text position\n          const x =\n            u.bbox.left + (isXHorizontal ? lft + wid / 2 : value < 0 ? lft - labelOffset : lft + wid + labelOffset);\n          let y =\n            u.bbox.top +\n            (isXHorizontal ? (value < 0 ? top + hgt + labelOffset : top - labelOffset) : top + hgt / 2 - middleShift);\n\n          // Retrieve textMetrics with necessary default values\n          // These _shouldn't_ be undefined at this point\n          // but they _could_ be.\n          const {\n            textMetrics = {\n              width: 1,\n              actualBoundingBoxAscent: 1,\n              actualBoundingBoxDescent: 1,\n            },\n          } = labels[dataIdx][seriesIdx];\n\n          // Adjust bounding boxes based on text scale\n          // factor and orientation (which changes the baseline)\n          let xAdjust = 0,\n            yAdjust = 0;\n\n          if (isXHorizontal) {\n            // Adjust for baseline which is \"top\" in this case\n            xAdjust = (textMetrics.width * scaleFactor) / 2;\n\n            // yAdjust only matters when the value isn't negative\n            yAdjust =\n              value > 0\n                ? (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor\n                : 0;\n          } else {\n            // Adjust from the baseline which is \"middle\" in this case\n            yAdjust = ((textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor) / 2;\n\n            // Adjust for baseline being \"right\" in the x direction\n            xAdjust = value < 0 ? textMetrics.width * scaleFactor : 0;\n          }\n\n          // Force label bounding box y position to not be negative\n          if (y - yAdjust < 0) {\n            y = yAdjust;\n          }\n\n          // Construct final bounding box for the label text\n          labels[dataIdx][seriesIdx].x = x;\n          labels[dataIdx][seriesIdx].y = y;\n          labels[dataIdx][seriesIdx].bbox = {\n            x: x - xAdjust,\n            y: y - yAdjust,\n            w: textMetrics.width * scaleFactor,\n            h: (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor,\n          };\n        }\n      }\n    },\n  });\n\n  const init = (u: uPlot) => {\n    u.root.querySelectorAll<HTMLDivElement>('.u-cursor-pt').forEach((el) => {\n      el.style.borderRadius = '0';\n\n      if (opts.fullHighlight) {\n        el.style.zIndex = '-1';\n      }\n    });\n  };\n\n  const cursor: uPlot.Cursor = {\n    x: false,\n    y: false,\n    drag: {\n      x: false,\n      y: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 0) {\n        hovered.fill(null);\n        hRect = null;\n\n        let cx = u.cursor.left! * uPlot.pxRatio;\n        let cy = u.cursor.top! * uPlot.pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = hovered[0] = o;\n            hovered[hRect.sidx] = hRect;\n\n            hoverMulti &&\n              findRects(qt, undefined, hRect.didx).forEach((r) => {\n                hovered[r.sidx] = r;\n              });\n          }\n        });\n      }\n\n      return hovered[seriesIdx]?.didx;\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.4)',\n      bbox: (u, seriesIdx) => {\n        let hRect2 = hovered[seriesIdx];\n        let isHovered = hRect2 != null;\n\n        return {\n          left: isHovered ? hRect2!.x / uPlot.pxRatio : -10,\n          top: isHovered ? hRect2!.y / uPlot.pxRatio : -10,\n          width: isHovered ? hRect2!.w / uPlot.pxRatio : 0,\n          height: isHovered ? hRect2!.h / uPlot.pxRatio : 0,\n        };\n      },\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hRect?.sidx === seriesIdx ? 0 : Infinity),\n    },\n  };\n\n  // Build bars\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear();\n\n    // clear the path cache to force drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n\n    if (isStacked) {\n      barsPctLayout = [null, ...distrOne(u.data[0].length, u.data.length - 1)];\n    } else {\n      barsPctLayout = [null, ...distrTwo(u.data[0].length, u.data.length - 1)];\n    }\n\n    if (useMappedColors) {\n      barsColors = [null];\n\n      // map per-bar colors\n      for (let i = 1; i < u.data.length; i++) {\n        let colors = (u.data[i] as Array<number | null>).map((value, valueIdx) => {\n          if (value != null) {\n            return getColor!(i, valueIdx, value);\n          }\n\n          return null;\n        });\n\n        barsColors.push({\n          fill:\n            fillOpacity < 1 ? colors.map((c) => (c != null ? colorManipulator.alpha(c, fillOpacity) : null)) : colors,\n          stroke: colors,\n        });\n      }\n    }\n\n    labels = {};\n    fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n    labelOffset = LABEL_OFFSET_MAX;\n    vSpace = hSpace = Infinity;\n  };\n\n  // uPlot hook to draw the labels on the bar chart.\n  const draw = (u: uPlot) => {\n    if (showValue === VisibilityMode.Never || fontSize < VALUE_MIN_FONT_SIZE) {\n      return;\n    }\n\n    u.ctx.save();\n    u.ctx.fillStyle = theme.colors.text.primary;\n    u.ctx.font = `${fontSize}px ${theme.typography.fontFamily}`;\n\n    let curAlign: CanvasTextAlign | undefined = undefined,\n      curBaseline: CanvasTextBaseline | undefined = undefined;\n\n    for (const didx in labels) {\n      // exclude first label from overlap testing\n      let first = true;\n\n      for (const sidx in labels[didx]) {\n        const label = labels[didx][sidx];\n        const { text, x = 0, y = 0 } = label;\n        let { value } = label;\n\n        if (opts.negY?.[sidx] && value != null) {\n          value *= -1;\n        }\n\n        let align: CanvasTextAlign = isXHorizontal ? 'center' : value !== null && value < 0 ? 'right' : 'left';\n        let baseline: CanvasTextBaseline = isXHorizontal\n          ? value !== null && value < 0\n            ? 'top'\n            : 'alphabetic'\n          : 'middle';\n\n        if (align !== curAlign) {\n          u.ctx.textAlign = curAlign = align;\n        }\n\n        if (baseline !== curBaseline) {\n          u.ctx.textBaseline = curBaseline = baseline;\n        }\n\n        if (showValue === VisibilityMode.Always) {\n          u.ctx.fillText(text, x, y);\n        } else if (showValue === VisibilityMode.Auto) {\n          let { bbox } = label;\n\n          let intersectsLabel = false;\n\n          if (bbox == null) {\n            intersectsLabel = true;\n            label.hidden = true;\n          } else if (!first) {\n            // Test for any collisions\n            for (const subsidx in labels[didx]) {\n              if (subsidx === sidx) {\n                continue;\n              }\n\n              const label2 = labels[didx][subsidx];\n              const { bbox: bbox2, hidden } = label2;\n\n              if (!hidden && bbox2 && intersects(bbox, bbox2)) {\n                intersectsLabel = true;\n                label.hidden = true;\n                break;\n              }\n            }\n          }\n\n          first = false;\n\n          !intersectsLabel && u.ctx.fillText(text, x, y);\n        }\n      }\n    }\n\n    u.ctx.restore();\n  };\n\n  let alignedTotals: AlignedData | null = null;\n\n  function prepData(frames: DataFrame[], stackingGroups: StackingGroup[]) {\n    alignedTotals = null;\n    return preparePlotData2(frames[0], stackingGroups, ({ totals }) => {\n      alignedTotals = totals;\n    });\n  }\n\n  return {\n    cursor,\n    // scale & axis opts\n    xRange,\n    xValues,\n    xSplits,\n    hFilter,\n\n    barsBuilder,\n\n    // hooks\n    init,\n    drawClear,\n    draw,\n    prepData,\n  };\n}\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip, common.OptionsWithTextFormatting {\n  /**\n   * Controls the radius of each bar.\n   */\n  barRadius?: number;\n  /**\n   * Controls the width of bars. 1 = Max width, 0 = Min width.\n   */\n  barWidth: number;\n  /**\n   * Use the color value for a sibling field to color each bar value.\n   */\n  colorByField?: string;\n  /**\n   * Enables mode which highlights the entire bar area and shows tooltip when cursor\n   * hovers over highlighted area\n   */\n  fullHighlight: boolean;\n  /**\n   * Controls the width of groups. 1 = max with, 0 = min width.\n   */\n  groupWidth: number;\n  /**\n   * Controls the orientation of the bar chart, either vertical or horizontal.\n   */\n  orientation: common.VizOrientation;\n  /**\n   * This controls whether values are shown on top or to the left of bars.\n   */\n  showValue: common.VisibilityMode;\n  /**\n   * Controls whether bars are stacked or not, either normally or in percent mode.\n   */\n  stacking: common.StackingMode;\n  /**\n   * Manually select which field from the dataset to represent the x field.\n   */\n  xField?: string;\n  /**\n   * Sets the max length that a label can have before it is truncated.\n   */\n  xTickLabelMaxLength: number;\n  /**\n   * Controls the rotation of the x axis labels.\n   */\n  xTickLabelRotation: number;\n  /**\n   * Controls the spacing between x axis labels.\n   * negative values indicate backwards skipping behavior\n   */\n  xTickLabelSpacing?: number;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  barRadius: 0,\n  barWidth: 0.97,\n  fullHighlight: false,\n  groupWidth: 0.7,\n  orientation: common.VizOrientation.Auto,\n  showValue: common.VisibilityMode.Auto,\n  stacking: common.StackingMode.None,\n  xTickLabelRotation: 0,\n  xTickLabelSpacing: 0,\n};\n\nexport interface FieldConfig extends common.AxisConfig, common.HideableFieldConfig {\n  /**\n   * Controls the fill opacity of the bars.\n   */\n  fillOpacity?: number;\n  /**\n   * Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.\n   * Gradient appearance is influenced by the Fill opacity setting.\n   */\n  gradientMode?: common.GraphGradientMode;\n  /**\n   * Controls line width of the bars.\n   */\n  lineWidth?: number;\n  /**\n   * Threshold rendering\n   */\n  thresholdsStyle?: common.GraphThresholdsStyleConfig;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 80,\n  gradientMode: common.GraphGradientMode.None,\n  lineWidth: 1,\n};\n","import uPlot, { Padding } from 'uplot';\n\nimport {\n  DataFrame,\n  Field,\n  FieldConfigSource,\n  FieldType,\n  GrafanaTheme2,\n  cacheFieldDisplayNames,\n  formattedValueToString,\n  getDisplayProcessor,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  outerJoinDataFrames,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/internal';\nimport { t } from '@grafana/i18n';\nimport {\n  AxisColorMode,\n  AxisPlacement,\n  FieldColorModeId,\n  GraphThresholdsStyleMode,\n  GraphTransform,\n  ScaleDistribution,\n  TimeZone,\n  TooltipDisplayMode,\n  VizOrientation,\n} from '@grafana/schema';\nimport {\n  FIXED_UNIT,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n  UPlotConfigBuilder,\n  measureText,\n} from '@grafana/ui';\nimport { AxisProps, UPLOT_AXIS_FONT_SIZE, getStackingGroups } from '@grafana/ui/internal';\n\nimport { setClassicPaletteIdxs } from '../timeseries/utils';\n\nimport { BarsOptions, getConfig } from './bars';\nimport { FieldConfig, Options, defaultFieldConfig } from './panelcfg.gen';\n// import { isLegendOrdered } from './utils';\n\ninterface BarSeries {\n  series: DataFrame[];\n  _rest: Field[];\n  color?: Field | null;\n  warn?: string | null;\n}\n\nexport function prepSeries(\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource,\n  stacking: StackingMode,\n  theme: GrafanaTheme2,\n  xFieldName?: string,\n  colorFieldName?: string\n): BarSeries {\n  // this allows PanelDataErrorView to show the default noValue message\n  if (frames.length === 0 || frames.every((fr) => fr.length === 0)) {\n    return {\n      warn: '',\n      series: [],\n      _rest: [],\n    };\n  }\n\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let frame: DataFrame | undefined = { ...frames[0] };\n\n  // auto-sort and/or join on first time field (if any)\n  // TODO: should this always join on the xField (if supplied?)\n  const timeFieldIdx = frame.fields.findIndex((f) => f.type === FieldType.time);\n\n  if (timeFieldIdx >= 0 && frames.length > 1) {\n    frame = outerJoinDataFrames({ frames, keepDisplayNames: true }) ?? frame;\n  }\n\n  const xField =\n    // TODO: use matcher\n    frame.fields.find((field) => field.state?.displayName === xFieldName || field.name === xFieldName) ??\n    frame.fields.find((field) => field.type === FieldType.string) ??\n    frame.fields[timeFieldIdx];\n\n  if (xField != null) {\n    const fields: Field[] = [xField];\n    const _rest: Field[] = [];\n\n    const colorField =\n      colorFieldName == null\n        ? undefined\n        : frame.fields.find(\n            // TODO: use matcher\n            (field) => field.state?.displayName === colorFieldName || field.name === colorFieldName\n          );\n\n    frame.fields.forEach((field) => {\n      if (field !== xField) {\n        if (field.type === FieldType.number && !field.config.custom?.hideFrom?.viz) {\n          const field2 = {\n            ...field,\n            values: field.values.map((v) => (Number.isFinite(v) ? v : null)),\n            // TODO: stacking should be moved from panel opts to fieldConfig (like TimeSeries) so we dont have to do this\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                stacking: {\n                  group: '_',\n                  mode: stacking,\n                },\n              },\n            },\n          };\n\n          fields.push(field2);\n        } else {\n          _rest.push(field);\n        }\n      }\n    });\n\n    let warn: string | null = null;\n\n    if (fields.length === 1) {\n      warn = t('bar-chart.warn.missing-numeric', 'No numeric fields found');\n    }\n\n    frame.fields = fields;\n\n    const series = [frame];\n\n    setClassicPaletteIdxs(series, theme, 0);\n\n    return {\n      series,\n      _rest,\n      color: colorField,\n      warn,\n    };\n  }\n\n  return {\n    series: [],\n    _rest: [],\n    color: null,\n    warn: t('bar-chart.warn.missing-series', 'Bar charts require a string or time field'),\n  };\n}\n\nexport interface PrepConfigOpts {\n  series: DataFrame[]; // series with hideFrom.viz: false\n  totalSeries: number; // total series count (including hidden)\n  color?: Field | null;\n  orientation: VizOrientation;\n  options: Options;\n  timeZone: TimeZone;\n  theme: GrafanaTheme2;\n}\n\nexport const prepConfig = ({ series, totalSeries, color, orientation, options, timeZone, theme }: PrepConfigOpts) => {\n  let {\n    showValue,\n    groupWidth,\n    barWidth,\n    barRadius = 0,\n    stacking,\n    text,\n    tooltip,\n    xTickLabelRotation,\n    xTickLabelMaxLength,\n    xTickLabelSpacing = 0,\n    legend,\n    fullHighlight,\n  } = options;\n  // this and color is kept up to date by returned prepData()\n  let frame = series[0];\n\n  const builder = new UPlotConfigBuilder();\n\n  const formatters = frame.fields.map((f, i) => {\n    if (stacking === StackingMode.Percent) {\n      return getDisplayProcessor({\n        field: {\n          ...f,\n          config: {\n            ...f.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n\n    return f.display!;\n  });\n\n  const formatValue = (seriesIdx: number, value: unknown) => {\n    return formattedValueToString(formatters[seriesIdx](value));\n  };\n\n  const formatShortValue = (seriesIdx: number, value: unknown) => {\n    return shortenValue(formatValue(seriesIdx, value), xTickLabelMaxLength);\n  };\n\n  // bar orientation -> x scale orientation & direction\n  const vizOrientation = getScaleOrientation(orientation);\n\n  // Use bar width when only one field\n  if (frame.fields.length === 2 && stacking === StackingMode.None) {\n    if (totalSeries === 1) {\n      groupWidth = barWidth;\n    }\n\n    barWidth = 1;\n  }\n\n  const rawValue = (seriesIdx: number, valueIdx: number) => {\n    return frame.fields[seriesIdx].values[valueIdx];\n  };\n\n  // Color by value\n  let getColor: ((seriesIdx: number, valueIdx: number) => string) | undefined = undefined;\n\n  let fillOpacity = 1;\n\n  if (color != null) {\n    const disp = color.display!;\n    fillOpacity = (color.config.custom.fillOpacity ?? 100) / 100;\n    // gradientMode? ignore?\n    getColor = (seriesIdx: number, valueIdx: number) => disp(color!.values[valueIdx]).color!;\n  } else {\n    const hasPerBarColor = frame.fields.some((f) => {\n      const fromThresholds = f.config.color?.mode === FieldColorModeId.Thresholds;\n\n      return (\n        fromThresholds ||\n        f.config.mappings?.some((m) => {\n          // ValueToText mappings have a different format, where all of them are grouped into an object keyed by value\n          if (m.type === 'value') {\n            // === MappingType.ValueToText\n            return Object.values(m.options).some((result) => result.color != null);\n          }\n          return m.options.result.color != null;\n        })\n      );\n    });\n\n    if (hasPerBarColor) {\n      // use opacity from first numeric field\n      let opacityField = frame.fields.find((f) => f.type === FieldType.number)!;\n\n      fillOpacity = (opacityField?.config?.custom?.fillOpacity ?? 100) / 100;\n\n      getColor = (seriesIdx: number, valueIdx: number) => {\n        let field = frame.fields[seriesIdx];\n        return field.display!(field.values[valueIdx]).color!;\n      };\n    }\n  }\n\n  const opts: BarsOptions = {\n    xOri: vizOrientation.xOri,\n    xDir: vizOrientation.xDir,\n    groupWidth,\n    barWidth,\n    barRadius,\n    stacking,\n    rawValue,\n    getColor,\n    fillOpacity,\n    formatValue,\n    formatShortValue,\n    timeZone,\n    text,\n    showValue,\n    legend,\n    xSpacing: xTickLabelSpacing,\n    xTimeAuto: frame.fields[0]?.type === FieldType.time && !frame.fields[0].config.unit?.startsWith('time:'),\n    negY: frame.fields.map((f) => f.config.custom?.transform === GraphTransform.NegativeY),\n    fullHighlight,\n    hoverMulti: tooltip.mode === TooltipDisplayMode.Multi,\n  };\n\n  const config = getConfig(opts, theme);\n\n  builder.setCursor(config.cursor);\n\n  builder.addHook('init', config.init);\n  builder.addHook('drawClear', config.drawClear);\n  builder.addHook('draw', config.draw);\n\n  if (xTickLabelRotation !== 0) {\n    // these are the amount of space we already have available between plot edge and first label\n    // TODO: removing these hardcoded value requires reading back uplot instance props\n    let lftSpace = 50;\n    let btmSpace = vizOrientation.xOri === ScaleOrientation.Horizontal ? 14 : 5;\n\n    builder.setPadding(getRotationPadding(frame, xTickLabelRotation, xTickLabelMaxLength, lftSpace, btmSpace));\n  }\n\n  builder.setPrepData(config.prepData);\n\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    range: config.xRange,\n    distribution: ScaleDistribution.Ordinal,\n    orientation: vizOrientation.xOri,\n    direction: vizOrientation.xDir,\n  });\n\n  const xFieldAxisPlacement =\n    frame.fields[0]?.config.custom?.axisPlacement !== AxisPlacement.Hidden\n      ? vizOrientation.xOri === ScaleOrientation.Horizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left\n      : AxisPlacement.Hidden;\n  const xFieldAxisShow = frame.fields[0]?.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: xFieldAxisPlacement,\n    label: frame.fields[0]?.config.custom?.axisLabel,\n    splits: config.xSplits,\n    filter: vizOrientation.xOri === 0 ? config.hFilter : undefined,\n    values: config.xValues,\n    timeZone,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: 15,\n    tickLabelRotation: vizOrientation.xOri === 0 ? xTickLabelRotation * -1 : 0,\n    theme,\n    show: xFieldAxisShow,\n  });\n\n  // let seriesIndex = 0;\n  // const legendOrdered = isLegendOrdered(legend);\n\n  // iterate the y values\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    // seriesIndex++;\n\n    const customConfig: FieldConfig = { ...defaultFieldConfig, ...field.config.custom };\n\n    const scaleKey = field.config.unit || FIXED_UNIT;\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // make barcharts start at 0 unless explicitly overridden\n    let softMin = customConfig.axisSoftMin;\n    let softMax = customConfig.axisSoftMax;\n\n    if (softMin == null && field.config.min == null) {\n      softMin = 0;\n    }\n\n    if (softMax == null && field.config.max == null) {\n      softMax = 0;\n    }\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && field.config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphThresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphThresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: field.config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n\n    builder.addSeries({\n      scaleKey,\n      pxAlign: true,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder: config.barsBuilder,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      // PlotLegend currently gets unfiltered DataFrame[], so index must be into that field array, not the prepped frame's which we're iterating here\n      // dataFrameFieldIndex: {\n      //   fieldIndex: legendOrdered\n      //     ? i\n      //     : allFrames[0].fields.findIndex(\n      //         (f) => f.type === FieldType.number && f.state?.seriesIndex === seriesIndex - 1\n      //       ),\n      //   frameIndex: 0,\n      // },\n    });\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale({\n      scaleKey,\n      min: field.config.min,\n      max: field.config.max,\n      softMin,\n      softMax,\n      centeredZero: customConfig.axisCenteredZero,\n      orientation: vizOrientation.yOri,\n      direction: vizOrientation.yDir,\n      distribution: customConfig.scaleDistribution?.type,\n      log: customConfig.scaleDistribution?.log,\n      decimals: field.config.decimals,\n    });\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let placement = customConfig.axisPlacement;\n      if (!placement || placement === AxisPlacement.Auto) {\n        placement = AxisPlacement.Left;\n      }\n      if (vizOrientation.xOri === 1) {\n        if (placement === AxisPlacement.Left) {\n          placement = AxisPlacement.Bottom;\n        }\n        if (placement === AxisPlacement.Right) {\n          placement = AxisPlacement.Top;\n        }\n      }\n\n      let axisOpts: AxisProps = {\n        scaleKey,\n        label: customConfig.axisLabel,\n        size: customConfig.axisWidth,\n        placement,\n        formatValue: (v, decimals) => formattedValueToString(field.display!(v, decimals)),\n        filter: vizOrientation.yOri === 0 ? config.hFilter : undefined,\n        tickLabelRotation: vizOrientation.xOri === 1 ? xTickLabelRotation * -1 : 0,\n        theme,\n        grid: { show: customConfig.axisGridShow },\n        decimals: field.config.decimals,\n      };\n\n      if (customConfig.axisBorderShow) {\n        axisOpts.border = {\n          show: true,\n        };\n      }\n\n      if (customConfig.axisColorMode === AxisColorMode.Series) {\n        axisOpts.color = seriesColor;\n      }\n\n      builder.addAxis(axisOpts);\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  return {\n    builder,\n    prepData: (_series: DataFrame[], _color?: Field | null) => {\n      series = _series;\n      frame = series[0];\n      color = _color;\n\n      return builder.prepData!(series);\n    },\n  };\n};\n\nfunction shortenValue(value: string, length: number) {\n  if (value.length > length) {\n    return value.substring(0, length).concat('...');\n  } else {\n    return value;\n  }\n}\n\nfunction getRotationPadding(\n  frame: DataFrame,\n  rotateLabel: number,\n  valueMaxLength: number,\n  lftSpace = 0,\n  btmSpace = 0\n): Padding {\n  const values = frame.fields[0].values;\n  const fontSize = UPLOT_AXIS_FONT_SIZE;\n  const displayProcessor = frame.fields[0].display;\n  const getProcessedValue = (i: number) => {\n    return displayProcessor ? displayProcessor(values[i]) : values[i];\n  };\n  let maxLength = 0;\n  for (let i = 0; i < values.length; i++) {\n    let size = measureText(shortenValue(formattedValueToString(getProcessedValue(i)), valueMaxLength), fontSize);\n    maxLength = size.width > maxLength ? size.width : maxLength;\n  }\n\n  // Add padding to the right if the labels are rotated in a way that makes the last label extend outside the graph.\n  const paddingRight =\n    rotateLabel > 0\n      ? Math.cos((rotateLabel * Math.PI) / 180) *\n        measureText(\n          shortenValue(formattedValueToString(getProcessedValue(values.length - 1)), valueMaxLength),\n          fontSize\n        ).width\n      : 0;\n\n  // Add padding to the left if the labels are rotated in a way that makes the first label extend outside the graph.\n  const paddingLeft =\n    rotateLabel < 0\n      ? Math.cos((rotateLabel * -1 * Math.PI) / 180) *\n        measureText(shortenValue(formattedValueToString(getProcessedValue(0)), valueMaxLength), fontSize).width\n      : 0;\n\n  // Add padding to the bottom to avoid clipping the rotated labels.\n  const paddingBottom =\n    Math.sin(((rotateLabel >= 0 ? rotateLabel : rotateLabel * -1) * Math.PI) / 180) * maxLength - btmSpace;\n\n  return [\n    Math.round(UPLOT_AXIS_FONT_SIZE * uPlot.pxRatio),\n    paddingRight,\n    paddingBottom,\n    Math.max(0, paddingLeft - lftSpace),\n  ];\n}\n\nfunction getScaleOrientation(orientation: VizOrientation) {\n  if (orientation === VizOrientation.Vertical) {\n    return {\n      xOri: ScaleOrientation.Horizontal,\n      xDir: ScaleDirection.Right,\n      yOri: ScaleOrientation.Vertical,\n      yDir: ScaleDirection.Up,\n    };\n  }\n\n  return {\n    xOri: ScaleOrientation.Vertical,\n    xDir: ScaleDirection.Down,\n    yOri: ScaleOrientation.Horizontal,\n    yDir: ScaleDirection.Right,\n  };\n}\n","import { useMemo } from 'react';\n\nimport { PanelProps, VizOrientation } from '@grafana/data';\nimport { config, PanelDataErrorView } from '@grafana/runtime';\nimport {\n  AdHocFilterItem,\n  TooltipDisplayMode,\n  TooltipPlugin2,\n  UPLOT_AXIS_FONT_SIZE,\n  UPlotChart,\n  VizLayout,\n  measureText,\n  usePanelContext,\n  useTheme2,\n} from '@grafana/ui';\nimport { AdHocFilterModel, FILTER_FOR_OPERATOR, TooltipHoverMode } from '@grafana/ui/internal';\n\nimport { TimeSeriesTooltip } from '../timeseries/TimeSeriesTooltip';\n\nimport { BarChartLegend, hasVisibleLegendSeries } from './BarChartLegend';\nimport { Options } from './panelcfg.gen';\nimport { prepConfig, prepSeries } from './utils';\n\nconst charWidth = measureText('M', UPLOT_AXIS_FONT_SIZE).width;\nconst toRads = Math.PI / 180;\n\nexport const BarChartPanel = (props: PanelProps<Options>) => {\n  const { data, options, fieldConfig, width, height, timeZone, id, replaceVariables } = props;\n\n  // will need this if joining on time to re-create data links\n  // const { dataLinkPostProcessor } = usePanelContext();\n\n  const theme = useTheme2();\n  const { onAddAdHocFilter, canExecuteActions } = usePanelContext();\n\n  const userCanExecuteActions = useMemo(() => canExecuteActions?.() ?? false, [canExecuteActions]);\n\n  const {\n    barWidth,\n    barRadius = 0,\n    showValue,\n    groupWidth,\n    stacking,\n    legend,\n    tooltip,\n    text,\n    xTickLabelRotation,\n    xTickLabelSpacing,\n    fullHighlight,\n    xField,\n    colorByField,\n  } = options;\n\n  // size-dependent, calculated opts that should cause viz re-config\n  let { orientation, xTickLabelMaxLength = 0 } = options;\n\n  orientation =\n    orientation === VizOrientation.Auto\n      ? width < height\n        ? VizOrientation.Horizontal\n        : VizOrientation.Vertical\n      : orientation;\n\n  // TODO: this can be moved into axis calc internally, no need to re-config based on this\n  // should be based on vizHeight, not full height?\n  xTickLabelMaxLength =\n    xTickLabelRotation === 0\n      ? Infinity // should this calc using spacing between groups?\n      : xTickLabelMaxLength ||\n        // auto max length clamps to half viz height, subracts 3 chars for ... ellipsis\n        Math.floor(height / 2 / Math.sin(Math.abs(xTickLabelRotation * toRads)) / charWidth - 3);\n\n  // TODO: config data links\n  const info = useMemo(\n    () => prepSeries(data.series, fieldConfig, stacking, theme, xField, colorByField),\n    [data.series, fieldConfig, stacking, theme, xField, colorByField]\n  );\n\n  const vizSeries = useMemo(\n    () =>\n      info.series.map((frame) => ({\n        ...frame,\n        fields: frame.fields.filter((field, i) => i === 0 || !field.state?.hideFrom?.viz),\n      })),\n    [info.series]\n  );\n\n  const xGroupsCount = vizSeries[0]?.length ?? 0;\n  const seriesCount = vizSeries[0]?.fields.length ?? 0;\n  const totalSeries = Math.max(0, (info.series[0]?.fields.length ?? 0) - 1);\n\n  let { builder, prepData } = useMemo(\n    () => {\n      return xGroupsCount === 0\n        ? { builder: null, prepData: null }\n        : prepConfig({ series: vizSeries, totalSeries, color: info.color, orientation, options, timeZone, theme });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      orientation,\n      timeZone,\n      props.data.structureRev,\n\n      totalSeries,\n      seriesCount,\n      xGroupsCount,\n\n      barWidth,\n      barRadius,\n      showValue,\n      groupWidth,\n      stacking,\n      legend,\n      tooltip,\n      text?.valueSize, // cause text obj is re-created each time?\n      xTickLabelRotation,\n      xTickLabelSpacing,\n      fullHighlight,\n      xField,\n      colorByField,\n      xTickLabelMaxLength, // maybe not?\n      // props.fieldConfig, // usePrevious hideFrom on all fields?\n    ]\n  );\n\n  const plotData = useMemo(\n    () => (prepData == null ? [] : prepData(vizSeries, info.color)),\n    [prepData, vizSeries, info.color]\n  );\n\n  if (info.warn != null || builder == null) {\n    return (\n      <PanelDataErrorView\n        panelId={id}\n        fieldConfig={fieldConfig}\n        data={data}\n        message={info.warn ?? ''}\n        needsNumberField={true}\n      />\n    );\n  }\n\n  const legendComp =\n    legend.showLegend && hasVisibleLegendSeries(builder, info.series!) ? (\n      <BarChartLegend data={info.series!} colorField={info.color} {...legend} />\n    ) : null;\n\n  return (\n    <VizLayout\n      width={props.width}\n      height={props.height}\n      // legend={<BarChartLegend frame={info.series![0]} colorField={info.color} {...legend} />}\n      legend={legendComp}\n    >\n      {(vizWidth, vizHeight) => (\n        <UPlotChart config={builder!} data={plotData} width={vizWidth} height={vizHeight}>\n          {props.options.tooltip.mode !== TooltipDisplayMode.None && (\n            <TooltipPlugin2\n              config={builder}\n              maxWidth={options.tooltip.maxWidth}\n              hoverMode={\n                options.tooltip.mode === TooltipDisplayMode.Single ? TooltipHoverMode.xOne : TooltipHoverMode.xAll\n              }\n              getDataLinks={(seriesIdx, dataIdx) =>\n                vizSeries[0].fields[seriesIdx].getLinks?.({ valueRowIndex: dataIdx }) ?? []\n              }\n              getAdHocFilters={(_seriesIdx, dataIdx) => {\n                const xField = vizSeries[0].fields[0];\n\n                // Check if the field supports filtering\n                // We only show filters on filterable fields (xField.config.filterable).\n                // Fields will have been marked as filterable by the data source if that data source supports adhoc filtering\n                // (eg. Prom or Loki) and the field types support adhoc filtering (eg. string or number - depending on the data source).\n                // Fields may later be marked as not filterable. For example, fields created from Grafana Transforms that\n                // are derived from a data source, but are not present in the data source.\n                // We choose `xField` here because it contains the label-value pair, rather than `field` which is the numeric Value.\n                if (\n                  config.featureToggles.adhocFiltersInTooltips &&\n                  xField.config.filterable &&\n                  onAddAdHocFilter != null\n                ) {\n                  const adHocFilterItem: AdHocFilterItem = {\n                    key: xField.name,\n                    operator: FILTER_FOR_OPERATOR,\n                    value: String(xField.values[dataIdx]),\n                  };\n\n                  const adHocFilters: AdHocFilterModel[] = [\n                    {\n                      ...adHocFilterItem,\n                      onClick: () => onAddAdHocFilter(adHocFilterItem),\n                    },\n                  ];\n\n                  return adHocFilters;\n                }\n\n                return [];\n              }}\n              render={(u, dataIdxs, seriesIdx, isPinned, dismiss, timeRange2, viaSync, dataLinks, adHocFilters) => {\n                return (\n                  <TimeSeriesTooltip\n                    series={vizSeries[0]}\n                    _rest={info._rest}\n                    dataIdxs={dataIdxs}\n                    seriesIdx={seriesIdx}\n                    mode={options.tooltip.mode}\n                    sortOrder={options.tooltip.sort}\n                    isPinned={isPinned}\n                    maxHeight={options.tooltip.maxHeight}\n                    replaceVariables={replaceVariables}\n                    dataLinks={dataLinks}\n                    adHocFilters={adHocFilters}\n                    hideZeros={options.tooltip.hideZeros}\n                    canExecuteActions={userCanExecuteActions}\n                  />\n                );\n              }}\n            />\n          )}\n        </UPlotChart>\n      )}\n    </VizLayout>\n  );\n};\n","import { SelectableValue, StandardEditorProps } from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { Checkbox, Stack, RadioButtonGroup, Tooltip } from '@grafana/ui';\n\nexport const TickSpacingEditor = (props: StandardEditorProps<number>) => {\n  const GAPS_OPTIONS: Array<SelectableValue<number>> = [\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-none', 'None'),\n      value: 0,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-none', 'Show all tick marks'),\n    },\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-small', 'Small'),\n      value: 100,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-small', 'Require {{spacing}} spacing', {\n        spacing: '100px',\n      }),\n    },\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-medium', 'Medium'),\n      value: 200,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-medium', 'Require {{spacing}} spacing', {\n        spacing: '200px',\n      }),\n    },\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-large', 'Large'),\n      value: 300,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-large', 'Require {{spacing}} spacing', {\n        spacing: '300px',\n      }),\n    },\n  ];\n  let value = props.value ?? 0;\n  const isRTL = value < 0;\n  if (isRTL) {\n    value *= -1;\n  }\n  let gap = GAPS_OPTIONS[0];\n  for (const v of GAPS_OPTIONS) {\n    gap = v;\n    if (value <= gap.value!) {\n      break;\n    }\n  }\n\n  const onSpacingChange = (val: number) => {\n    props.onChange(val * (isRTL ? -1 : 1));\n  };\n\n  const onRTLChange = () => {\n    props.onChange(props.value * -1);\n  };\n\n  return (\n    <Stack>\n      <RadioButtonGroup value={gap.value} options={GAPS_OPTIONS} onChange={onSpacingChange} />\n      {value !== 0 && (\n        <Tooltip\n          content={t(\n            'barchart.tick-spacing-editor.content-require-space-from-the-right-side',\n            'Require space from the right side'\n          )}\n          placement=\"top\"\n        >\n          <div>\n            <Checkbox value={isRTL} onChange={onRTLChange} label={t('barchart.tick-spacing-editor.label-rtl', 'RTL')} />\n          </div>\n        </Tooltip>\n      )}\n    </Stack>\n  );\n};\n","import { FieldMatcherID, PanelTypeChangedHandler, ReducerID } from '@grafana/data';\nimport { AxisPlacement } from '@grafana/ui';\n\n/*\n * This is called when the panel changes from another panel\n */\nexport const changeToBarChartPanelMigrationHandler: PanelTypeChangedHandler = (panel, prevPluginId, prevOptions) => {\n  if (prevPluginId === 'graph') {\n    const graphOptions: GraphOptions = prevOptions.angular;\n\n    const fieldConfig = panel.fieldConfig ?? { defaults: {}, overrides: [] };\n\n    if (graphOptions.xaxis?.mode === 'series') {\n      const transformations = panel.transformations || [];\n      transformations.push(\n        {\n          id: 'reduce',\n          options: {\n            reducers: getReducer(graphOptions.xaxis?.values),\n          },\n        },\n        {\n          id: 'transpose',\n          options: {},\n        }\n      );\n\n      panel.transformations = transformations;\n\n      // temporary, until we have a bar chart with per bar labels\n      fieldConfig.overrides.push({\n        matcher: {\n          id: FieldMatcherID.byName,\n          options: 'Field',\n        },\n        properties: [\n          {\n            id: 'custom.axisPlacement',\n            value: AxisPlacement.Hidden,\n          },\n        ],\n      });\n\n      panel.fieldConfig = fieldConfig;\n      panel.options = {\n        ...panel.options,\n        groupWidth: 1,\n      };\n    }\n  }\n\n  return {};\n};\n\n// same as grafana-ui/src/components/SingleStatShared/SingleStatBaseOptions.ts\nconst getReducer = (reducers: string[] | undefined) => {\n  const transformReducers: string[] = [];\n\n  reducers?.forEach((reducer) => {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    if (!Object.values(ReducerID).includes(reducer as ReducerID)) {\n      if (reducer === 'current') {\n        transformReducers.push(ReducerID.lastNotNull);\n      } else if (reducer === 'total') {\n        transformReducers.push(ReducerID.sum);\n      } else if (reducer === 'avg') {\n        transformReducers.push(ReducerID.mean);\n      }\n    } else {\n      transformReducers.push(reducer);\n    }\n  });\n\n  return reducers ? transformReducers : [ReducerID.sum];\n};\n\ninterface GraphOptions {\n  xaxis: {\n    mode: 'series' | 'time' | 'histogram';\n    values?: string[];\n  };\n}\n","import { VisualizationSuggestionsBuilder, VizOrientation } from '@grafana/data';\nimport { LegendDisplayMode, StackingMode, VisibilityMode } from '@grafana/schema';\nimport { SuggestionName } from 'app/types/suggestions';\n\nimport { FieldConfig, Options } from './panelcfg.gen';\n\nexport class BarChartSuggestionsSupplier {\n  getListWithDefaults(builder: VisualizationSuggestionsBuilder) {\n    return builder.getListAppender<Options, FieldConfig>({\n      name: SuggestionName.BarChart,\n      pluginId: 'barchart',\n      options: {\n        showValue: VisibilityMode.Never,\n        legend: {\n          calcs: [],\n          displayMode: LegendDisplayMode.List,\n          showLegend: true,\n          placement: 'right',\n        },\n      },\n      fieldConfig: {\n        defaults: {\n          unit: 'short',\n          custom: {},\n        },\n        overrides: [],\n      },\n      cardOptions: {\n        previewModifier: (s) => {\n          s.options!.barWidth = 0.8;\n        },\n      },\n    });\n  }\n\n  getSuggestionsForData(builder: VisualizationSuggestionsBuilder) {\n    const list = this.getListWithDefaults(builder);\n    const { dataSummary } = builder;\n\n    if (dataSummary.frameCount !== 1) {\n      return;\n    }\n\n    if (!dataSummary.hasNumberField || !dataSummary.hasStringField) {\n      return;\n    }\n\n    // if you have this many rows barchart might not be a good fit\n    if (dataSummary.rowCountTotal > 50) {\n      return;\n    }\n\n    // Vertical bars\n    list.append({\n      name: SuggestionName.BarChart,\n    });\n\n    if (dataSummary.numberFieldCount > 1) {\n      list.append({\n        name: SuggestionName.BarChartStacked,\n        options: {\n          stacking: StackingMode.Normal,\n        },\n      });\n      list.append({\n        name: SuggestionName.BarChartStackedPercent,\n        options: {\n          stacking: StackingMode.Percent,\n        },\n      });\n    }\n\n    // horizontal bars\n    list.append({\n      name: SuggestionName.BarChartHorizontal,\n      options: {\n        orientation: VizOrientation.Horizontal,\n      },\n    });\n\n    if (dataSummary.numberFieldCount > 1) {\n      list.append({\n        name: SuggestionName.BarChartHorizontalStacked,\n        options: {\n          stacking: StackingMode.Normal,\n          orientation: VizOrientation.Horizontal,\n        },\n      });\n\n      list.append({\n        name: SuggestionName.BarChartHorizontalStackedPercent,\n        options: {\n          orientation: VizOrientation.Horizontal,\n          stacking: StackingMode.Percent,\n        },\n      });\n    }\n  }\n}\n","import {\n  DataFrame,\n  FieldColorModeId,\n  FieldConfigProperty,\n  FieldType,\n  identityOverrideProcessor,\n  PanelPlugin,\n  VizOrientation,\n} from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { GraphTransform, GraphThresholdsStyleMode, StackingMode, VisibilityMode } from '@grafana/schema';\nimport { getGraphFieldOptions, commonOptionsBuilder } from '@grafana/ui';\nimport { optsWithHideZeros } from '@grafana/ui/internal';\n\nimport { ThresholdsStyleEditor } from '../timeseries/ThresholdsStyleEditor';\n\nimport { BarChartPanel } from './BarChartPanel';\nimport { TickSpacingEditor } from './TickSpacingEditor';\nimport { changeToBarChartPanelMigrationHandler } from './migrations';\nimport { FieldConfig, Options, defaultFieldConfig, defaultOptions } from './panelcfg.gen';\nimport { BarChartSuggestionsSupplier } from './suggestions';\n\nexport const plugin = new PanelPlugin<Options, FieldConfig>(BarChartPanel)\n  .setPanelChangeHandler(changeToBarChartPanelMigrationHandler)\n  .useFieldConfig({\n    standardOptions: {\n      [FieldConfigProperty.Color]: {\n        settings: {\n          byValueSupport: true,\n          preferThresholdsMode: false,\n        },\n        defaultValue: {\n          mode: FieldColorModeId.PaletteClassic,\n        },\n      },\n      [FieldConfigProperty.Links]: {\n        settings: {\n          showOneClick: true,\n        },\n      },\n      [FieldConfigProperty.Actions]: {\n        hideFromDefaults: false,\n      },\n    },\n    useCustomConfig: (builder) => {\n      const cfg = defaultFieldConfig;\n\n      builder\n        .addSliderInput({\n          path: 'lineWidth',\n          name: t('barchart.config.name-line-width', 'Line width'),\n          defaultValue: cfg.lineWidth,\n          settings: {\n            min: 0,\n            max: 10,\n            step: 1,\n          },\n        })\n        .addSliderInput({\n          path: 'fillOpacity',\n          name: t('barchart.config.name-fill-opacity', 'Fill opacity'),\n          defaultValue: cfg.fillOpacity,\n          settings: {\n            min: 0,\n            max: 100,\n            step: 1,\n          },\n        })\n        .addRadio({\n          path: 'gradientMode',\n          name: t('barchart.config.name-gradient-mode', 'Gradient mode'),\n          defaultValue: getGraphFieldOptions().fillGradient[0].value,\n          settings: {\n            options: getGraphFieldOptions().fillGradient,\n          },\n        });\n\n      builder.addSelect({\n        category: ['Graph styles'],\n        name: t('barchart.config.name-transform', 'Transform'),\n        path: 'transform',\n        settings: {\n          options: [\n            {\n              label: t('barchart.config.transform-options.label-constant', 'Constant'),\n              value: GraphTransform.Constant,\n              description: t(\n                'barchart.config.transform-options.description-constant',\n                'The first value will be shown as a constant line'\n              ),\n            },\n            {\n              label: t('barchart.config.transform-options.label-negative-y', 'Negative Y'),\n              value: GraphTransform.NegativeY,\n              description: t(\n                'barchart.config.transform-options.description-negative-y',\n                'Flip the results to negative values on the y axis'\n              ),\n            },\n          ],\n          isClearable: true,\n        },\n        hideFromDefaults: true,\n      });\n\n      builder.addCustomEditor({\n        id: 'thresholdsStyle',\n        path: 'thresholdsStyle',\n        name: t('barchart.config.name-show-thresholds', 'Show thresholds'),\n        category: [t('barchart.config.category-thresholds', 'Thresholds')],\n        defaultValue: { mode: GraphThresholdsStyleMode.Off },\n        settings: {\n          options: getGraphFieldOptions().thresholdsDisplayModes,\n        },\n        editor: ThresholdsStyleEditor,\n        override: ThresholdsStyleEditor,\n        process: identityOverrideProcessor,\n        shouldApply: () => true,\n      });\n\n      commonOptionsBuilder.addAxisConfig(builder, cfg);\n      commonOptionsBuilder.addHideFrom(builder);\n    },\n  })\n  .setPanelOptions((builder) => {\n    builder\n      .addFieldNamePicker({\n        path: 'xField',\n        name: t('barchart.config.name-x-axis', 'X Axis'),\n        settings: {\n          placeholderText: t('barchart.config.placeholder-x-axis', 'First string or time field'),\n        },\n      })\n      .addRadio({\n        path: 'orientation',\n        name: t('barchart.config.name-orientation', 'Orientation'),\n        settings: {\n          options: [\n            { value: VizOrientation.Auto, label: t('barchart.config.orientation-options.label-auto', 'Auto') },\n            {\n              value: VizOrientation.Horizontal,\n              label: t('barchart.config.orientation-options.label-horizontal', 'Horizontal'),\n            },\n            {\n              value: VizOrientation.Vertical,\n              label: t('barchart.config.orientation-options.label-line-vertical', 'Vertical'),\n            },\n          ],\n        },\n        defaultValue: defaultOptions.orientation,\n      })\n      .addSliderInput({\n        path: 'xTickLabelRotation',\n        name: t('barchart.config.name-rotate-x-labels', 'Rotate x-axis tick labels'),\n        defaultValue: defaultOptions.xTickLabelRotation,\n        settings: {\n          min: -90,\n          max: 90,\n          step: 15,\n          marks: { '-90': '-90', '-45': '-45', 0: '0', 45: '45', 90: '90' },\n          included: false,\n        },\n      })\n      .addNumberInput({\n        path: 'xTickLabelMaxLength',\n        name: t('barchart.config.name-x-label-max-length', 'X-axis tick label max length'),\n        description: t(\n          'barchart.config.description-x-label-max-length',\n          'X-axis labels will be truncated to the length provided'\n        ),\n        settings: {\n          placeholder: t('barchart.config.placeholder-x-label-max-length', 'None'),\n          min: 0,\n        },\n        showIf: (opts) => opts.xTickLabelRotation !== 0,\n      })\n      .addCustomEditor({\n        id: 'xTickLabelSpacing',\n        path: 'xTickLabelSpacing',\n        name: t('barchart.config.name-x-label-min-spacing', 'X-axis labels minimum spacing'),\n        defaultValue: defaultOptions.xTickLabelSpacing,\n        editor: TickSpacingEditor,\n      })\n      .addRadio({\n        path: 'showValue',\n        name: t('barchart.config.name-show-values', 'Show values'),\n        settings: {\n          options: [\n            { value: VisibilityMode.Auto, label: t('barchart.config.show-values-options.label-auto', 'Auto') },\n            { value: VisibilityMode.Always, label: t('barchart.config.show-values-options.label-always', 'Always') },\n            { value: VisibilityMode.Never, label: t('barchart.config.show-values-options.label-never', 'Never') },\n          ],\n        },\n        defaultValue: defaultOptions.showValue,\n      })\n      .addRadio({\n        path: 'stacking',\n        name: t('barchart.config.name-stacking', 'Stacking'),\n        settings: {\n          options: getGraphFieldOptions().stacking,\n        },\n        defaultValue: defaultOptions.stacking,\n      })\n      .addSliderInput({\n        path: 'groupWidth',\n        name: t('barchart.config.name-group-width', 'Group width'),\n        defaultValue: defaultOptions.groupWidth,\n        settings: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        showIf: (c, data) => {\n          if (c.stacking && c.stacking !== StackingMode.None) {\n            return false;\n          }\n          return countNumberFields(data) !== 1;\n        },\n      })\n      .addSliderInput({\n        path: 'barWidth',\n        name: t('barchart.config.name-bar-width', 'Bar width'),\n        defaultValue: defaultOptions.barWidth,\n        settings: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n      })\n      .addSliderInput({\n        path: 'barRadius',\n        name: t('barchart.config.name-bar-radius', 'Bar radius'),\n        defaultValue: defaultOptions.barRadius,\n        settings: {\n          min: 0,\n          max: 0.5,\n          step: 0.05,\n        },\n      })\n      .addBooleanSwitch({\n        path: 'fullHighlight',\n        name: t('barchart.config.name-full-highlight', 'Highlight full area on hover'),\n        defaultValue: defaultOptions.fullHighlight,\n        showIf: (c) => c.stacking === StackingMode.None,\n      });\n\n    builder.addFieldNamePicker({\n      path: 'colorByField',\n      name: t('barchart.config.name-color-by-field', 'Color by field'),\n      description: t(\n        'barchart.config.description-color-by-field',\n        'Use the color value for a sibling field to color each bar value.'\n      ),\n    });\n\n    commonOptionsBuilder.addTooltipOptions(builder, false, false, optsWithHideZeros);\n    commonOptionsBuilder.addLegendOptions(builder);\n    commonOptionsBuilder.addTextSizeOptions(builder, false);\n  })\n  .setSuggestionsSupplier(new BarChartSuggestionsSupplier());\n\nfunction countNumberFields(data?: DataFrame[]): number {\n  let count = 0;\n  if (data) {\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        if (field.type === FieldType.number) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}\n","import { css } from '@emotion/css';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\n\nimport { VizTooltipRow } from './VizTooltipRow';\nimport { VizTooltipItem } from './types';\n\ninterface Props {\n  item: VizTooltipItem;\n  isPinned: boolean;\n}\nexport const VizTooltipHeader = ({ item, isPinned }: Props) => {\n  const styles = useStyles2(getStyles);\n\n  const { label, value, color, colorIndicator } = item;\n\n  return (\n    <div className={styles.wrapper}>\n      <VizTooltipRow\n        label={label}\n        value={value}\n        color={color}\n        colorIndicator={colorIndicator}\n        marginRight={'22px'}\n        isPinned={isPinned}\n      />\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    flex: 1,\n    padding: theme.spacing(1),\n    lineHeight: 1,\n  }),\n});\n","import { css } from '@emotion/css';\nimport { CSSProperties, ReactNode } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\n\nimport { VizTooltipRow } from './VizTooltipRow';\nimport { VizTooltipItem } from './types';\n\ninterface VizTooltipContentProps {\n  items: VizTooltipItem[];\n  children?: ReactNode;\n  scrollable?: boolean;\n  isPinned: boolean;\n  maxHeight?: number;\n}\n\nexport const VizTooltipContent = ({\n  items,\n  children,\n  isPinned,\n  scrollable = false,\n  maxHeight,\n}: VizTooltipContentProps) => {\n  const styles = useStyles2(getStyles);\n\n  const scrollableStyle: CSSProperties = scrollable\n    ? {\n        maxHeight: maxHeight,\n        overflowY: 'auto',\n      }\n    : {};\n\n  return (\n    <div className={styles.wrapper} style={scrollableStyle}>\n      {items.map(({ label, value, color, colorIndicator, colorPlacement, isActive, lineStyle, isHiddenFromViz }, i) => (\n        <VizTooltipRow\n          key={i}\n          label={label}\n          value={value}\n          color={color}\n          colorIndicator={colorIndicator}\n          colorPlacement={colorPlacement}\n          isActive={isActive}\n          justify={'space-between'}\n          isPinned={isPinned}\n          lineStyle={lineStyle}\n          showValueScroll={!scrollable}\n          isHiddenFromViz={isHiddenFromViz}\n        />\n      ))}\n      {children}\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    flex: 1,\n    gap: 2,\n    borderTop: `1px solid ${theme.colors.border.weak}`,\n    padding: theme.spacing(1),\n  }),\n});\n","import {\n  DataFrame,\n  Field,\n  FieldType,\n  getDisplayProcessor,\n  GrafanaTheme2,\n  isBooleanUnit,\n  TimeRange,\n  cacheFieldDisplayNames,\n  applyNullInsertThreshold,\n  nullToValue,\n} from '@grafana/data';\nimport { convertFieldType } from '@grafana/data/internal';\nimport { GraphFieldConfig, LineInterpolation, TooltipDisplayMode, VizTooltipOptions } from '@grafana/schema';\nimport { buildScaleKey } from '@grafana/ui/internal';\n\nimport { HeatmapTooltip } from '../heatmap/panelcfg.gen';\n\ntype ScaleKey = string;\n\n// this will re-enumerate all enum fields on the same scale to create one ordinal progression\n// e.g. ['a','b'][0,1,0] + ['c','d'][1,0,1] -> ['a','b'][0,1,0] + ['c','d'][3,2,3]\nfunction reEnumFields(frames: DataFrame[]): DataFrame[] {\n  let allTextsByKey: Map<ScaleKey, string[]> = new Map();\n\n  let frames2: DataFrame[] = frames.map((frame) => {\n    return {\n      ...frame,\n      fields: frame.fields.map((field) => {\n        if (field.type === FieldType.enum) {\n          let scaleKey = buildScaleKey(field.config, field.type);\n          let allTexts = allTextsByKey.get(scaleKey);\n\n          if (!allTexts) {\n            allTexts = [];\n            allTextsByKey.set(scaleKey, allTexts);\n          }\n\n          let idxs: number[] = field.values.toArray().slice();\n          let txts = field.config.type!.enum!.text!;\n\n          // by-reference incrementing\n          if (allTexts.length > 0) {\n            for (let i = 0; i < idxs.length; i++) {\n              idxs[i] += allTexts.length;\n            }\n          }\n\n          allTexts.push(...txts);\n\n          // shared among all enum fields on same scale\n          field.config.type!.enum!.text! = allTexts;\n\n          return {\n            ...field,\n            values: idxs,\n          };\n\n          // TODO: update displayProcessor?\n        }\n\n        return field;\n      }),\n    };\n  });\n\n  return frames2;\n}\n\n/**\n * Returns null if there are no graphable fields\n */\nexport function prepareGraphableFields(\n  series: DataFrame[],\n  theme: GrafanaTheme2,\n  timeRange?: TimeRange,\n  // numeric X requires a single frame where the first field is numeric\n  xNumFieldIdx?: number\n): DataFrame[] | null {\n  if (!series?.length) {\n    return null;\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let useNumericX = xNumFieldIdx != null;\n\n  // Make sure the numeric x field is first in the frame\n  if (xNumFieldIdx != null && xNumFieldIdx > 0) {\n    series = [\n      {\n        ...series[0],\n        fields: [series[0].fields[xNumFieldIdx], ...series[0].fields.filter((f, i) => i !== xNumFieldIdx)],\n      },\n    ];\n  }\n\n  // some datasources simply tag the field as time, but don't convert to milli epochs\n  // so we're stuck with doing the parsing here to avoid Moment slowness everywhere later\n  // this mutates (once)\n  for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.time && typeof field.values[0] !== 'number') {\n        field.values = convertFieldType(field, { destinationType: FieldType.time }).values;\n      }\n    }\n  }\n\n  let enumFieldsCount = 0;\n\n  loopy: for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.enum && ++enumFieldsCount > 1) {\n        series = reEnumFields(series);\n        break loopy;\n      }\n    }\n  }\n\n  let copy: Field;\n\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    const fields: Field[] = [];\n\n    let hasTimeField = false;\n    let hasValueField = false;\n\n    let nulledFrame = useNumericX\n      ? frame\n      : applyNullInsertThreshold({\n          frame,\n          refFieldPseudoMin: timeRange?.from.valueOf(),\n          refFieldPseudoMax: timeRange?.to.valueOf(),\n        });\n\n    const frameFields = nullToValue(nulledFrame).fields;\n\n    for (let fieldIdx = 0; fieldIdx < (frameFields?.length || 0); fieldIdx++) {\n      const field = frameFields[fieldIdx];\n\n      switch (field.type) {\n        case FieldType.time:\n          hasTimeField = true;\n          fields.push(field);\n          break;\n        case FieldType.number:\n          hasValueField = useNumericX ? fieldIdx > 0 : true;\n          copy = {\n            ...field,\n            values: field.values.map((v) => {\n              if (!(Number.isFinite(v) || v == null)) {\n                return null;\n              }\n              return v;\n            }),\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.enum:\n          hasValueField = true;\n        case FieldType.string:\n          copy = {\n            ...field,\n            values: field.values,\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.boolean:\n          hasValueField = true;\n          const custom: GraphFieldConfig = field.config?.custom ?? {};\n          const config = {\n            ...field.config,\n            max: 1,\n            min: 0,\n            custom,\n          };\n\n          // smooth and linear do not make sense\n          if (custom.lineInterpolation !== LineInterpolation.StepBefore) {\n            custom.lineInterpolation = LineInterpolation.StepAfter;\n          }\n\n          copy = {\n            ...field,\n            config,\n            type: FieldType.number,\n            values: field.values.map((v) => {\n              if (v == null) {\n                return v;\n              }\n              return Boolean(v) ? 1 : 0;\n            }),\n          };\n\n          if (!isBooleanUnit(config.unit)) {\n            config.unit = 'bool';\n            copy.display = getDisplayProcessor({ field: copy, theme });\n          }\n\n          fields.push(copy);\n          break;\n      }\n    }\n\n    if ((useNumericX || hasTimeField) && hasValueField) {\n      frames.push({\n        ...frame,\n        length: nulledFrame.length,\n        fields,\n      });\n    }\n  }\n\n  if (frames.length) {\n    setClassicPaletteIdxs(frames, theme, 0);\n    matchEnumColorToSeriesColor(frames, theme);\n    return frames;\n  }\n\n  return null;\n}\n\nconst matchEnumColorToSeriesColor = (frames: DataFrame[], theme: GrafanaTheme2) => {\n  const { palette } = theme.visualization;\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type === FieldType.enum) {\n        const namedColor = palette[field.state?.seriesIndex! % palette.length];\n        const hexColor = theme.visualization.getColorByName(namedColor);\n        const enumConfig = field.config.type!.enum!;\n\n        enumConfig.color = Array(enumConfig.text!.length).fill(hexColor);\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    }\n  }\n};\n\nexport const setClassicPaletteIdxs = (frames: DataFrame[], theme: GrafanaTheme2, skipFieldIdx?: number) => {\n  let seriesIndex = 0;\n  frames.forEach((frame) => {\n    frame.fields.forEach((field, fieldIdx) => {\n      if (\n        fieldIdx !== skipFieldIdx &&\n        (field.type === FieldType.number || field.type === FieldType.boolean || field.type === FieldType.enum)\n      ) {\n        field.state = {\n          ...field.state,\n          seriesIndex: seriesIndex++, // TODO: skip this for fields with custom renderers (e.g. Candlestick)?\n        };\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    });\n  });\n};\n\nexport function getTimezones(timezones: string[] | undefined, defaultTimezone: string): string[] {\n  if (!timezones || !timezones.length) {\n    return [defaultTimezone];\n  }\n  return timezones.map((v) => (v?.length ? v : defaultTimezone));\n}\n\nexport const isTooltipScrollable = (tooltipOptions: VizTooltipOptions | HeatmapTooltip) => {\n  return tooltipOptions.mode === TooltipDisplayMode.Multi && tooltipOptions.maxHeight != null;\n};\n","import { css, cx } from '@emotion/css';\n\nimport { FALLBACK_COLOR, GrafanaTheme2 } from '@grafana/data';\nimport { LineStyle } from '@grafana/schema';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\nimport { SeriesIcon } from '../VizLegend/SeriesIcon';\n\nimport { ColorIndicator, DEFAULT_COLOR_INDICATOR } from './types';\nimport { getColorIndicatorClass } from './utils';\n\nexport enum ColorIndicatorPosition {\n  Leading,\n  Trailing,\n}\n\ninterface Props {\n  color?: string;\n  colorIndicator?: ColorIndicator;\n  position?: ColorIndicatorPosition;\n  lineStyle?: LineStyle;\n  isHollow?: boolean;\n}\n\nexport type ColorIndicatorStyles = ReturnType<typeof getStyles>;\n\nexport const VizTooltipColorIndicator = ({\n  color = FALLBACK_COLOR,\n  colorIndicator = DEFAULT_COLOR_INDICATOR,\n  position = ColorIndicatorPosition.Leading,\n  lineStyle,\n  isHollow,\n}: Props) => {\n  const styles = useStyles2(getStyles);\n\n  if (isHollow) {\n    return (\n      <div\n        style={{ border: `1px solid ${color}` }}\n        className={cx(\n          position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing,\n          getColorIndicatorClass(colorIndicator, styles)\n        )}\n      />\n    );\n  }\n\n  if (colorIndicator === ColorIndicator.series) {\n    return (\n      <SeriesIcon\n        color={color}\n        lineStyle={lineStyle}\n        className={position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing}\n      />\n    );\n  }\n\n  return (\n    <span\n      style={{ backgroundColor: color }}\n      className={cx(\n        position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing,\n        getColorIndicatorClass(colorIndicator, styles)\n      )}\n    />\n  );\n};\n\n// @TODO Update classes/add svgs\nconst getStyles = (theme: GrafanaTheme2) => ({\n  leading: css({\n    marginRight: theme.spacing(0.5),\n  }),\n  trailing: css({\n    marginLeft: theme.spacing(0.5),\n  }),\n  series: css({\n    width: '14px',\n    height: '4px',\n    borderRadius: theme.shape.radius.pill,\n    minWidth: '14px',\n  }),\n  value: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.default,\n    fontWeight: 500,\n    minWidth: '12px',\n  }),\n  hexagon: css({}),\n  pie_1_4: css({}),\n  pie_2_4: css({}),\n  pie_3_4: css({}),\n  marker_sm: css({\n    width: '4px',\n    height: '4px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '4px',\n  }),\n  marker_md: css({\n    width: '8px',\n    height: '8px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '8px',\n  }),\n  marker_lg: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '12px',\n  }),\n});\n","import { css, cx } from '@emotion/css';\nimport { CSSProperties, ReactNode, useEffect, useRef, useState } from 'react';\nimport * as React from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\nimport { InlineToast } from '../InlineToast/InlineToast';\nimport { Tooltip } from '../Tooltip/Tooltip';\n\nimport { ColorIndicatorPosition, VizTooltipColorIndicator } from './VizTooltipColorIndicator';\nimport { ColorPlacement, VizTooltipItem } from './types';\n\ninterface VizTooltipRowProps extends Omit<VizTooltipItem, 'value'> {\n  value: string | number | null | ReactNode;\n  justify?: string;\n  isActive?: boolean; // for series list\n  marginRight?: string;\n  isPinned: boolean;\n  showValueScroll?: boolean;\n  isHiddenFromViz?: boolean;\n}\n\nenum LabelValueTypes {\n  label = 'label',\n  value = 'value',\n}\n\nconst SUCCESSFULLY_COPIED_TEXT = 'Copied to clipboard';\nconst SHOW_SUCCESS_DURATION = 2 * 1000;\nconst HORIZONTAL_PX_PER_CHAR = 7;\n\nexport const VizTooltipRow = ({\n  label,\n  value,\n  color,\n  colorIndicator,\n  colorPlacement = ColorPlacement.first,\n  justify = 'flex-start',\n  isActive = false,\n  marginRight = '0px',\n  isPinned,\n  lineStyle,\n  showValueScroll,\n  isHiddenFromViz,\n}: VizTooltipRowProps) => {\n  const styles = useStyles2(getStyles, justify, marginRight);\n\n  const innerValueScrollStyle: CSSProperties = showValueScroll\n    ? {\n        maxHeight: 55,\n        whiteSpace: 'wrap',\n        wordBreak: 'break-word',\n        overflowY: 'auto',\n      }\n    : {\n        whiteSpace: 'pre-line',\n        wordBreak: 'break-word',\n        lineHeight: 1.2,\n      };\n\n  const [showLabelTooltip, setShowLabelTooltip] = useState(false);\n\n  const [copiedText, setCopiedText] = useState<Record<string, string> | null>(null);\n  const [showCopySuccess, setShowCopySuccess] = useState(false);\n\n  const labelRef = useRef<null | HTMLDivElement>(null);\n  const valueRef = useRef<null | HTMLDivElement>(null);\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n\n    if (showCopySuccess) {\n      timeoutId = setTimeout(() => {\n        setShowCopySuccess(false);\n      }, SHOW_SUCCESS_DURATION);\n    }\n\n    return () => {\n      window.clearTimeout(timeoutId);\n    };\n  }, [showCopySuccess]);\n\n  const copyToClipboard = async (text: string, type: LabelValueTypes) => {\n    if (!(navigator?.clipboard && window.isSecureContext)) {\n      fallbackCopyToClipboard(text, type);\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopiedText({ [`${type}`]: text });\n      setShowCopySuccess(true);\n    } catch (error) {\n      setCopiedText(null);\n    }\n  };\n\n  const fallbackCopyToClipboard = (text: string, type: LabelValueTypes) => {\n    // Use a fallback method for browsers/contexts that don't support the Clipboard API.\n    const textarea = document.createElement('textarea');\n    labelRef.current?.appendChild(textarea);\n    textarea.value = text;\n    textarea.focus();\n    textarea.select();\n    try {\n      const successful = document.execCommand('copy');\n      if (successful) {\n        setCopiedText({ [`${type}`]: text });\n        setShowCopySuccess(true);\n      }\n    } catch (err) {\n      console.error('Unable to copy to clipboard', err);\n    }\n\n    textarea.remove();\n  };\n\n  const onMouseEnterLabel = (event: React.MouseEvent<HTMLDivElement>) => {\n    if (event.currentTarget.offsetWidth < event.currentTarget.scrollWidth) {\n      setShowLabelTooltip(true);\n    }\n  };\n\n  const onMouseLeaveLabel = () => setShowLabelTooltip(false);\n\n  // if label is > 50% window width, try to put label/value pairs on new lines\n  if (label.length * HORIZONTAL_PX_PER_CHAR > window.innerWidth / 2) {\n    label = label.replaceAll('{', '{\\n  ').replaceAll('}', '\\n}').replaceAll(', ', ',\\n  ');\n  }\n\n  return (\n    <div className={styles.contentWrapper}>\n      {(color || label) && (\n        <div className={styles.valueWrapper}>\n          {color && colorPlacement === ColorPlacement.first && (\n            <VizTooltipColorIndicator\n              color={color}\n              colorIndicator={colorIndicator}\n              lineStyle={lineStyle}\n              isHollow={isHiddenFromViz}\n            />\n          )}\n          {!isPinned ? (\n            <div className={cx(styles.label, isActive && styles.activeSeries)}>{label}</div>\n          ) : (\n            <>\n              <Tooltip content={label} interactive={false} show={showLabelTooltip}>\n                <>\n                  {showCopySuccess && copiedText?.label && (\n                    <InlineToast placement=\"top\" referenceElement={labelRef.current}>\n                      {SUCCESSFULLY_COPIED_TEXT}\n                    </InlineToast>\n                  )}\n                  {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n                  <div\n                    className={cx(styles.label, isActive && styles.activeSeries, navigator?.clipboard && styles.copy)}\n                    onMouseEnter={onMouseEnterLabel}\n                    onMouseLeave={onMouseLeaveLabel}\n                    onClick={() => copyToClipboard(label, LabelValueTypes.label)}\n                    ref={labelRef}\n                  >\n                    {label}\n                  </div>\n                </>\n              </Tooltip>\n            </>\n          )}\n        </div>\n      )}\n\n      <div className={styles.valueWrapper}>\n        {color && colorPlacement === ColorPlacement.leading && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Leading}\n            lineStyle={lineStyle}\n          />\n        )}\n\n        {!isPinned ? (\n          <div className={cx(styles.value, isActive)} style={innerValueScrollStyle}>\n            {value}\n          </div>\n        ) : (\n          <>\n            {showCopySuccess && copiedText?.value && (\n              <InlineToast placement=\"top\" referenceElement={valueRef.current}>\n                {SUCCESSFULLY_COPIED_TEXT}\n              </InlineToast>\n            )}\n            {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n            <div\n              className={cx(styles.value, isActive, navigator?.clipboard && styles.copy)}\n              style={innerValueScrollStyle}\n              onClick={() => copyToClipboard(value ? value.toString() : '', LabelValueTypes.value)}\n              ref={valueRef}\n            >\n              {value}\n            </div>\n          </>\n        )}\n\n        {color && colorPlacement === ColorPlacement.trailing && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Trailing}\n            lineStyle={lineStyle}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2, justify: string, marginRight: string) => ({\n  contentWrapper: css({\n    display: 'flex',\n    alignItems: 'start',\n    justifyContent: justify,\n    marginRight: marginRight,\n  }),\n  label: css({\n    color: theme.colors.text.secondary,\n    fontWeight: 400,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    marginRight: theme.spacing(2),\n  }),\n  value: css({\n    fontWeight: 500,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n  }),\n  valueWrapper: css({\n    display: 'flex',\n    alignItems: 'center',\n  }),\n  activeSeries: css({\n    fontWeight: theme.typography.fontWeightBold,\n    color: theme.colors.text.maxContrast,\n  }),\n  copy: css({\n    cursor: 'pointer',\n  }),\n});\n","import { ReactNode } from 'react';\n\nimport { DataFrame, Field, FieldType, formattedValueToString, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport {\n  VizTooltipContent,\n  VizTooltipFooter,\n  VizTooltipHeader,\n  VizTooltipWrapper,\n  getContentItems,\n  VizTooltipItem,\n  AdHocFilterModel,\n} from '@grafana/ui/internal';\n\nimport { getFieldActions } from '../status-history/utils';\n\nimport { isTooltipScrollable } from './utils';\n\n// exemplar / annotation / time region hovering?\n// add annotation UI / alert dismiss UI?\n\nexport interface TimeSeriesTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n\n  // aligned fields that are not series\n  _rest?: Field[];\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n\n  annotate?: () => void;\n  maxHeight?: number;\n\n  replaceVariables?: InterpolateFunction;\n  dataLinks: LinkModel[];\n  hideZeros?: boolean;\n  adHocFilters?: AdHocFilterModel[];\n  canExecuteActions?: boolean;\n  compareDiffMs?: number[];\n}\n\nexport const TimeSeriesTooltip = ({\n  series,\n  _rest,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  maxHeight,\n  replaceVariables = (str) => str,\n  dataLinks,\n  hideZeros,\n  adHocFilters,\n  canExecuteActions,\n  compareDiffMs,\n}: TimeSeriesTooltipProps) => {\n  const xField = series.fields[0];\n\n  let xVal = xField.values[dataIdxs[0]!];\n\n  if (compareDiffMs != null && xField.type === FieldType.time) {\n    xVal += compareDiffMs[seriesIdx ?? 1];\n  }\n\n  const xDisp = formattedValueToString(xField.display!(xVal));\n\n  const contentItems = getContentItems(\n    series.fields,\n    xField,\n    dataIdxs,\n    seriesIdx,\n    mode,\n    sortOrder,\n    (field) => field.type === FieldType.number || field.type === FieldType.enum,\n    hideZeros,\n    _rest\n  );\n\n  let footer: ReactNode;\n\n  if (seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const hasOneClickLink = dataLinks.some((dataLink) => dataLink.oneClick === true);\n\n    if (isPinned || hasOneClickLink) {\n      const dataIdx = dataIdxs[seriesIdx]!;\n      const actions = canExecuteActions ? getFieldActions(series, field, replaceVariables, dataIdx) : [];\n\n      footer = (\n        <VizTooltipFooter dataLinks={dataLinks} actions={actions} annotate={annotate} adHocFilters={adHocFilters} />\n      );\n    }\n  }\n\n  const headerItem: VizTooltipItem = {\n    label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n    value: xDisp,\n  };\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n"],"names":["getDataLinks","field","rowIdx","links","v","disp","linkLookup","link","key","getAllFrameActions","dataFrame","getFieldActions","replaceVars","rowIndex","actions","actionLookup","action","hasVisibleLegendSeries","config","data","BarChartLegend","placement","calcs","displayMode","colorField","vizLayoutLegendProps","theme","fieldConfig","colorMode","thresholdItems","thresholdsAbsolute","thresholdsPercent","i","step","thresholdAbsoluteItems","thresholdPercentItems","valueMappings","mappings","mapping","valueMappingItems","legendItems","fieldIndex","label","color","VizLayout","VizLegend","intervals","groupDistr","barDistr","VALUE_MIN_FONT_SIZE","VALUE_MAX_FONT_SIZE","BAR_FONT_SIZE_RATIO","LABEL_OFFSET_FACTOR_VT","LABEL_OFFSET_FACTOR_HZ","LABEL_OFFSET_MAX_VT","LABEL_OFFSET_MAX_HZ","MIDDLE_BASELINE_SHIFT","calculateFontSizeWithMetrics","text","width","height","lineHeight","maxSize","textSize","measureText","fontSizeBasedOnWidth","fontSizeBasedOnHeight","optimalSize","getConfig","opts","xOri","dir","rawValue","getColor","formatValue","formatShortValue","fillOpacity","showValue","xSpacing","hoverMulti","timeZone","isXHorizontal","hasAutoValueSize","isStacked","pctStacked","groupWidth","barWidth","barRadius","qt","hovered","hRect","xSplits","u","hFilter","splits","dim","_dir","dataLen","lastIdx","skipMod","cssDim","maxTicks","splits2","xValues","axisIdx","foundSpace","foundIncr","format","xRange","min","max","pctOffset","distribute","di","lftPct","widPct","rn","offset","distrTwo","groupCount","barCount","out","groupIdx","groupOffPct","groupDimPct","barIdx","barOffPct","barDimPct","distrOne","LABEL_OFFSET_FACTOR","LABEL_OFFSET_MAX","barsPctLayout","barsColors","scaleFactor","labels","fontSize","labelOffset","vSpace","hSpace","useMappedColors","mappedColorDisp","seriesIdx","barsBuilder","dataIdx","lft","top","wid","hgt","val","barRect","raw","divider","alignedTotals","calculatedSize","textMetrics","autoFontSize","middleShift","value","x","y","xAdjust","yAdjust","init","el","cursor","cx","cy","o","r","hRect2","isHovered","drawClear","s","colors","valueIdx","c","colorManipulator","draw","curAlign","curBaseline","didx","first","sidx","align","baseline","bbox","intersectsLabel","subsidx","label2","bbox2","hidden","prepData","frames","stackingGroups","totals","defaultOptions","defaultFieldConfig","prepSeries","stacking","xFieldName","colorFieldName","fr","frame","timeFieldIdx","f","xField","fields","_rest","field2","warn","series","prepConfig","totalSeries","orientation","options","tooltip","xTickLabelRotation","xTickLabelMaxLength","xTickLabelSpacing","legend","fullHighlight","builder","UPlotConfigBuilder","formatters","shortenValue","vizOrientation","getScaleOrientation","m","result","lftSpace","btmSpace","getRotationPadding","xFieldAxisPlacement","xFieldAxisShow","customConfig","scaleKey","seriesColor","softMin","softMax","axisOpts","decimals","_series","_color","length","rotateLabel","valueMaxLength","values","displayProcessor","getProcessedValue","maxLength","size","paddingRight","paddingLeft","paddingBottom","charWidth","toRads","BarChartPanel","props","id","replaceVariables","onAddAdHocFilter","canExecuteActions","userCanExecuteActions","colorByField","info","vizSeries","xGroupsCount","seriesCount","plotData","PanelDataErrorView","legendComp","vizWidth","vizHeight","TooltipPlugin2","_seriesIdx","adHocFilterItem","dataIdxs","isPinned","dismiss","timeRange2","viaSync","dataLinks","adHocFilters","TimeSeriesTooltip","TickSpacingEditor","GAPS_OPTIONS","isRTL","gap","onSpacingChange","onRTLChange","Stack","RadioButtonGroup","Tooltip","Checkbox","changeToBarChartPanelMigrationHandler","panel","prevPluginId","prevOptions","graphOptions","transformations","getReducer","reducers","transformReducers","reducer","BarChartSuggestionsSupplier","list","dataSummary","PanelPlugin","cfg","ThresholdsStyleEditor","countNumberFields","count","VizTooltipHeader","item","styles","getStyles","colorIndicator","VizTooltipContent","items","children","scrollable","maxHeight","scrollableStyle","colorPlacement","isActive","lineStyle","isHiddenFromViz","reEnumFields","allTextsByKey","allTexts","idxs","txts","prepareGraphableFields","timeRange","xNumFieldIdx","useNumericX","enumFieldsCount","loopy","copy","hasTimeField","hasValueField","nulledFrame","frameFields","fieldIdx","custom","setClassicPaletteIdxs","matchEnumColorToSeriesColor","palette","namedColor","hexColor","enumConfig","skipFieldIdx","seriesIndex","getTimezones","timezones","defaultTimezone","isTooltipScrollable","tooltipOptions","ColorIndicatorPosition","VizTooltipColorIndicator","position","isHollow","SeriesIcon","LabelValueTypes","SUCCESSFULLY_COPIED_TEXT","SHOW_SUCCESS_DURATION","HORIZONTAL_PX_PER_CHAR","VizTooltipRow","justify","marginRight","showValueScroll","innerValueScrollStyle","showLabelTooltip","setShowLabelTooltip","copiedText","setCopiedText","showCopySuccess","setShowCopySuccess","labelRef","valueRef","timeoutId","copyToClipboard","type","fallbackCopyToClipboard","textarea","err","onMouseEnterLabel","event","onMouseLeaveLabel","InlineToast","mode","sortOrder","annotate","str","hideZeros","compareDiffMs","xVal","xDisp","contentItems","footer","hasOneClickLink","dataLink","headerItem"],"sourceRoot":""}