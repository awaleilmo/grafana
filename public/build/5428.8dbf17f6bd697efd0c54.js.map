{"version":3,"file":"5428.8dbf17f6bd697efd0c54.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/status-history/utils.ts","webpack://grafana/./packages/grafana-data/src/transformations/transformers/nulls/nullToUndefThreshold.ts","webpack://grafana/./public/app/core/components/GraphNG/utils.ts","webpack://grafana/./public/app/core/components/TimeSeries/utils.ts","webpack://grafana/./public/app/core/components/TimeSeries/TimeSeries.tsx","webpack://grafana/./public/app/core/components/GraphNG/GraphNG.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/TimeSeriesTooltip.tsx"],"sourcesContent":["import { DataFrame, ActionModel, Field, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { getActions } from 'app/features/actions/utils';\n\nexport const getDataLinks = (field: Field, rowIdx: number) => {\n  const links: Array<LinkModel<Field>> = [];\n\n  if ((field.config.links?.length ?? 0) > 0 && field.getLinks != null) {\n    const v = field.values[rowIdx];\n    const disp = field.display ? field.display(v) : { text: `${v}`, numeric: +v };\n\n    const linkLookup = new Set<string>();\n\n    field.getLinks({ calculatedValue: disp, valueRowIndex: rowIdx }).forEach((link) => {\n      const key = `${link.title}/${link.href}`;\n      if (!linkLookup.has(key)) {\n        links.push(link);\n        linkLookup.add(key);\n      }\n    });\n  }\n\n  return links;\n};\n\nexport const getAllFrameActions = (dataFrame: DataFrame) => {};\n\nexport const getFieldActions = (\n  dataFrame: DataFrame,\n  field: Field,\n  replaceVars: InterpolateFunction,\n  rowIndex: number\n) => {\n  const actions: Array<ActionModel<Field>> = [];\n  const actionLookup = new Set<string>();\n\n  const actionsModel = getActions(dataFrame, field, field.state!.scopedVars!, replaceVars, field.config.actions ?? [], {\n    valueRowIndex: rowIndex,\n  });\n\n  actionsModel.forEach((action) => {\n    const key = `${action.title}`;\n    if (!actionLookup.has(key)) {\n      actions.push(action);\n      actionLookup.add(key);\n    }\n  });\n\n  return actions;\n};\n","// mutates all nulls -> undefineds in the fieldValues array for value-less refValues ranges below maxThreshold\n// refValues is typically a time array and maxThreshold is the allowable distance between in time\nexport function nullToUndefThreshold(refValues: number[], fieldValues: unknown[], maxThreshold: number) {\n  let prevRef;\n  let nullIdx;\n\n  for (let i = 0; i < fieldValues.length; i++) {\n    let fieldVal = fieldValues[i];\n\n    if (fieldVal == null) {\n      if (nullIdx == null && prevRef != null) {\n        nullIdx = i;\n      }\n    } else {\n      if (nullIdx != null && prevRef != null) {\n        if (refValues[i] - prevRef < maxThreshold) {\n          while (nullIdx < i) {\n            fieldValues[nullIdx++] = undefined;\n          }\n        }\n\n        nullIdx = null;\n      }\n\n      prevRef = refValues[i];\n    }\n  }\n\n  return fieldValues;\n}\n","import {\n  DataFrame,\n  Field,\n  FieldType,\n  outerJoinDataFrames,\n  TimeRange,\n  applyNullInsertThreshold,\n  roundDecimals,\n} from '@grafana/data';\nimport { NULL_EXPAND, NULL_REMOVE, NULL_RETAIN, nullToUndefThreshold } from '@grafana/data/internal';\nimport { GraphDrawStyle } from '@grafana/schema';\n\nimport { XYFieldMatchers } from './types';\n\nfunction isVisibleBarField(f: Field) {\n  return (\n    f.type === FieldType.number && f.config.custom?.drawStyle === GraphDrawStyle.Bars && !f.config.custom?.hideFrom?.viz\n  );\n}\n\nexport function getRefField(frame: DataFrame, refFieldName?: string | null) {\n  return frame.fields.find((field) => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n}\n\n// will mutate the DataFrame's fields' values\nfunction applySpanNullsThresholds(frame: DataFrame, refFieldName?: string | null) {\n  const refField = getRefField(frame, refFieldName);\n\n  let refValues = refField?.values;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    let field = frame.fields[i];\n\n    if (field === refField || isVisibleBarField(field)) {\n      continue;\n    }\n\n    let spanNulls = field.config.custom?.spanNulls;\n\n    if (typeof spanNulls === 'number') {\n      if (spanNulls !== -1 && refValues) {\n        field.values = nullToUndefThreshold(refValues, field.values, spanNulls);\n      }\n    }\n  }\n\n  return frame;\n}\n\nfunction getXField(dimFields: XYFieldMatchers, frame: DataFrame, frames: DataFrame[]) {\n  for (let field of frame.fields) {\n    if (dimFields.x(field, frame, frames)) {\n      return field;\n    }\n  }\n\n  return;\n}\n\nexport function preparePlotFrame(frames: DataFrame[], dimFields: XYFieldMatchers, timeRange?: TimeRange | null) {\n  // apply null insertions at interval\n  frames = frames.map((frame) => {\n    const xField = getXField(dimFields, frame, frames);\n\n    if (xField != null && !xField.state?.nullThresholdApplied) {\n      return applyNullInsertThreshold({\n        frame,\n        refFieldName: xField.name,\n        refFieldPseudoMin: timeRange?.from.valueOf(),\n        refFieldPseudoMax: timeRange?.to.valueOf(),\n      });\n    } else {\n      return frame;\n    }\n  });\n\n  let numBarSeries = frames.reduce(\n    (acc, frame) => acc + frame.fields.reduce((acc, field) => acc + (isVisibleBarField(field) ? 1 : 0), 0),\n    0\n  );\n\n  // to make bar widths of all series uniform (equal to narrowest bar series), find smallest distance between x points\n  let minXDeltaGlobal: number | null = null;\n\n  if (numBarSeries > 1) {\n    // collect for each frame and only set minXDeltaGlobal if they're different\n    const minXDeltas = new Set<number>();\n\n    frames.forEach((frame) => {\n      if (!frame.fields.some(isVisibleBarField)) {\n        return;\n      }\n\n      const xField = getXField(dimFields, frame, frames);\n\n      if (xField == null) {\n        return;\n      }\n\n      let minXDeltaFrame = Infinity;\n\n      const xVals = xField.values;\n\n      for (let i = 0; i < xVals.length; i++) {\n        if (i > 0) {\n          minXDeltaFrame = Math.min(minXDeltaFrame, xVals[i] - xVals[i - 1]);\n        }\n      }\n\n      if (minXDeltaFrame !== Infinity) {\n        if (!Number.isInteger(minXDeltaFrame)) {\n          minXDeltaFrame = roundDecimals(minXDeltaFrame, 6);\n        }\n\n        minXDeltas.add(minXDeltaFrame);\n      }\n    });\n\n    if (minXDeltas.size > 1) {\n      minXDeltaGlobal = Math.min(...minXDeltas);\n    }\n  }\n\n  let alignedFrame = outerJoinDataFrames({\n    frames,\n    joinBy: dimFields.x,\n    keep: dimFields.y,\n    keepOriginIndices: true,\n\n    // the join transformer force-deletes our state.displayName cache unless keepDisplayNames: true\n    // https://github.com/grafana/grafana/pull/31121\n    // https://github.com/grafana/grafana/pull/71806\n    keepDisplayNames: true,\n\n    // prevent minesweeper-expansion of nulls (gaps) when joining bars\n    // since bar width is determined from the minimum distance between non-undefined values\n    // (this strategy will still retain any original pre-join nulls, though)\n    nullMode: (field) => {\n      if (isVisibleBarField(field)) {\n        return NULL_RETAIN;\n      }\n\n      let spanNulls = field.config.custom?.spanNulls;\n      return spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND;\n    },\n  });\n\n  if (alignedFrame) {\n    alignedFrame = applySpanNullsThresholds(alignedFrame, alignedFrame.fields[0].name);\n\n    // append 2 null vals at minXDeltaGlobal to bar series\n    if (minXDeltaGlobal != null) {\n      alignedFrame.fields.forEach((f, fi) => {\n        let vals = f.values;\n\n        if (fi === 0) {\n          let lastVal = vals[vals.length - 1];\n          vals.push(lastVal + minXDeltaGlobal, lastVal + 2 * minXDeltaGlobal);\n        } else if (isVisibleBarField(f)) {\n          vals.push(null, null);\n        } else {\n          vals.push(undefined, undefined);\n        }\n      });\n\n      alignedFrame.length += 2;\n    }\n\n    return alignedFrame;\n  }\n\n  return null;\n}\n","import { isNumber } from 'lodash';\nimport uPlot from 'uplot';\n\nimport {\n  DataFrame,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  getFieldDisplayName,\n  getDisplayProcessor,\n  FieldColorModeId,\n  DecimalCount,\n} from '@grafana/data';\n// eslint-disable-next-line import/order\nimport {\n  AxisPlacement,\n  GraphDrawStyle,\n  GraphFieldConfig,\n  GraphThresholdsStyleMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n  GraphTransform,\n  AxisColorMode,\n  GraphGradientMode,\n  VizOrientation,\n  ScaleDistributionConfig,\n} from '@grafana/schema';\n\n// unit lookup needed to determine if we want power-of-2 or power-of-10 axis ticks\n// see categories.ts is @grafana/data\nconst IEC_UNITS = new Set([\n  'bytes',\n  'bits',\n  'kbytes',\n  'mbytes',\n  'gbytes',\n  'tbytes',\n  'pbytes',\n  'binBps',\n  'binbps',\n  'KiBs',\n  'Kibits',\n  'MiBs',\n  'Mibits',\n  'GiBs',\n  'Gibits',\n  'TiBs',\n  'Tibits',\n  'PiBs',\n  'Pibits',\n]);\n\nconst BIN_INCRS = Array(53);\n\nfor (let i = 0; i < BIN_INCRS.length; i++) {\n  BIN_INCRS[i] = 2 ** i;\n}\n\nimport { DrawStyle } from '@grafana/ui';\nimport {\n  UPlotConfigBuilder,\n  UPlotConfigPrepFn,\n  getScaleGradientFn,\n  buildScaleKey,\n  getStackingGroups,\n  preparePlotData2,\n} from '@grafana/ui/internal';\n\nconst defaultFormatter = (v: any, decimals: DecimalCount = 1) => (v == null ? '-' : v.toFixed(decimals));\n\nconst defaultConfig: GraphFieldConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Auto,\n  showValues: false,\n};\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn = ({\n  frame,\n  theme,\n  timeZones,\n  getTimeRange,\n  allFrames,\n  renderers,\n  tweakScale = (opts) => opts,\n  tweakAxis = (opts) => opts,\n  hoverProximity,\n  orientation = VizOrientation.Horizontal,\n}) => {\n  // we want the Auto and Horizontal orientation to default to Horizontal\n  const isHorizontal = orientation !== VizOrientation.Vertical;\n  const builder = new UPlotConfigBuilder(timeZones[0]);\n\n  let alignedFrame: DataFrame;\n\n  builder.setPrepData((frames) => {\n    // cache alignedFrame\n    alignedFrame = frames[0];\n\n    return preparePlotData2(frames[0], builder.getStackingGroups());\n  });\n\n  // X is the first field in the aligned frame\n  const xField = frame.fields[0];\n  if (!xField) {\n    return builder; // empty frame with no options\n  }\n\n  const xScaleKey = 'x';\n  let yScaleKey = '';\n\n  const xFieldAxisPlacement =\n    xField.config.custom?.axisPlacement === AxisPlacement.Hidden\n      ? AxisPlacement.Hidden\n      : isHorizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left;\n  const xFieldAxisShow = xField.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  if (xField.type === FieldType.time) {\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: isHorizontal ? ScaleOrientation.Horizontal : ScaleOrientation.Vertical,\n      direction: isHorizontal ? ScaleDirection.Right : ScaleDirection.Up,\n      isTime: true,\n      range: () => {\n        const r = getTimeRange();\n        return [r.from.valueOf(), r.to.valueOf()];\n      },\n    });\n\n    // filters first 2 ticks to make space for timezone labels\n    const filterTicks: uPlot.Axis.Filter | undefined =\n      timeZones.length > 1\n        ? (u, splits) => {\n            if (isHorizontal) {\n              return splits.map((v, i) => (i < 2 ? null : v));\n            }\n            return splits;\n          }\n        : undefined;\n\n    for (let i = 0; i < timeZones.length; i++) {\n      const timeZone = timeZones[i];\n      builder.addAxis({\n        scaleKey: xScaleKey,\n        isTime: true,\n        placement: xFieldAxisPlacement,\n        show: xFieldAxisShow,\n        label: xField.config.custom?.axisLabel,\n        timeZone,\n        theme,\n        grid: { show: i === 0 && xField.config.custom?.axisGridShow },\n        filter: filterTicks,\n      });\n    }\n\n    // render timezone labels\n    if (timeZones.length > 1) {\n      builder.addHook('drawAxes', (u: uPlot) => {\n        u.ctx.save();\n\n        let i = 0;\n        u.axes.forEach((a) => {\n          if (isHorizontal && a.side === 2) {\n            u.ctx.fillStyle = theme.colors.text.primary;\n            u.ctx.textAlign = 'left';\n            u.ctx.textBaseline = 'bottom';\n            //@ts-ignore\n            let cssBaseline: number = a._pos + a._size;\n            u.ctx.fillText(timeZones[i], u.bbox.left, cssBaseline * uPlot.pxRatio);\n            i++;\n          }\n        });\n\n        u.ctx.restore();\n      });\n    }\n  } else {\n    let custom = xField.config.custom;\n    let scaleDistr: ScaleDistributionConfig = { ...custom?.scaleDistribution };\n\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: isHorizontal ? ScaleOrientation.Horizontal : ScaleOrientation.Vertical,\n      direction: isHorizontal ? ScaleDirection.Right : ScaleDirection.Up,\n      distribution: scaleDistr?.type,\n      log: scaleDistr?.log,\n      linearThreshold: scaleDistr?.linearThreshold,\n      min: xField.config.min,\n      max: xField.config.max,\n      softMin: custom?.axisSoftMin,\n      softMax: custom?.axisSoftMax,\n      centeredZero: custom?.axisCenteredZero,\n      decimals: xField.config.decimals,\n      padMinBy: 0,\n      padMaxBy: 0,\n    });\n\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: custom?.axisLabel,\n      theme,\n      grid: { show: custom?.axisGridShow },\n      formatValue: (v, decimals) => formattedValueToString(xField.display!(v, decimals)),\n    });\n  }\n\n  let customRenderedFields =\n    renderers?.flatMap((r) => Object.values(r.fieldMap).filter((name) => r.indicesOnly.indexOf(name) === -1)) ?? [];\n\n  let indexByName: Map<string, number> | undefined;\n\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    const config: FieldConfig<GraphFieldConfig> = {\n      ...field.config,\n      custom: {\n        ...defaultConfig,\n        ...field.config.custom,\n      },\n    };\n\n    const customConfig: GraphFieldConfig = config.custom!;\n\n    if (field === xField || (field.type !== FieldType.number && field.type !== FieldType.enum)) {\n      continue;\n    }\n\n    let fmt = field.display ?? defaultFormatter;\n    if (field.config.custom?.stacking?.mode === StackingMode.Percent) {\n      fmt = getDisplayProcessor({\n        field: {\n          ...field,\n          config: {\n            ...field.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n    const scaleKey = buildScaleKey(config, field.type);\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale(\n      tweakScale(\n        {\n          scaleKey,\n          orientation: isHorizontal ? ScaleOrientation.Vertical : ScaleOrientation.Horizontal,\n          direction: isHorizontal ? ScaleDirection.Up : ScaleDirection.Right,\n          distribution: customConfig.scaleDistribution?.type,\n          log: customConfig.scaleDistribution?.log,\n          linearThreshold: customConfig.scaleDistribution?.linearThreshold,\n          min: field.config.min,\n          max: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n          centeredZero: customConfig.axisCenteredZero,\n          stackingMode: customConfig.stacking?.mode,\n          range:\n            field.type === FieldType.enum\n              ? (u: uPlot, dataMin: number, dataMax: number) => {\n                  // this is the exhaustive enum (stable)\n                  let len = field.config.type!.enum!.text!.length;\n\n                  return [-1, len];\n\n                  // these are only values that are present\n                  // return [dataMin - 1, dataMax + 1]\n                }\n              : undefined,\n          decimals: field.config.decimals,\n        },\n        field\n      )\n    );\n\n    if (!yScaleKey) {\n      yScaleKey = scaleKey;\n    }\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let axisColor: uPlot.Axis.Stroke | undefined;\n\n      if (customConfig.axisColorMode === AxisColorMode.Series) {\n        if (\n          colorMode.isByValue &&\n          field.config.custom?.gradientMode === GraphGradientMode.Scheme &&\n          colorMode.id === FieldColorModeId.Thresholds\n        ) {\n          axisColor = getScaleGradientFn(1, theme, colorMode, field.config.thresholds);\n        } else {\n          axisColor = seriesColor;\n        }\n      }\n\n      const axisDisplayOptions = {\n        border: {\n          show: customConfig.axisBorderShow || false,\n          width: 1 / devicePixelRatio,\n          stroke: axisColor || theme.colors.text.primary,\n        },\n        ticks: {\n          show: customConfig.axisBorderShow || false,\n          stroke: axisColor || theme.colors.text.primary,\n        },\n        color: axisColor || theme.colors.text.primary,\n      };\n\n      let incrs: uPlot.Axis.Incrs | undefined;\n\n      // TODO: these will be dynamic with frame updates, so need to accept getYTickLabels()\n      let values: uPlot.Axis.Values | undefined;\n      let splits: uPlot.Axis.Splits | undefined;\n\n      if (IEC_UNITS.has(config.unit!)) {\n        incrs = BIN_INCRS;\n      } else if (field.type === FieldType.enum) {\n        let text = field.config.type!.enum!.text!;\n        splits = text.map((v: string, i: number) => i);\n        values = text;\n      }\n\n      builder.addAxis(\n        tweakAxis(\n          {\n            scaleKey,\n            label: customConfig.axisLabel,\n            size: customConfig.axisWidth,\n            placement: isHorizontal ? (customConfig.axisPlacement ?? AxisPlacement.Auto) : AxisPlacement.Bottom,\n            formatValue: (v, decimals) => formattedValueToString(fmt(v, decimals)),\n            theme,\n            grid: { show: customConfig.axisGridShow },\n            decimals: field.config.decimals,\n            distr: customConfig.scaleDistribution?.type,\n            splits,\n            values,\n            incrs,\n            ...axisDisplayOptions,\n          },\n          field\n        )\n      );\n    }\n\n    const showPoints =\n      customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n\n    let pointsFilter: uPlot.Series.Points.Filter = () => null;\n\n    if (customConfig.spanNulls !== true && showPoints === VisibilityMode.Auto) {\n      pointsFilter = (u, seriesIdx, show, gaps) => {\n        let filtered = [];\n\n        if (!show) {\n          const yData = u.data[seriesIdx];\n\n          if (gaps && gaps.length) {\n            const firstIdx = u.posToIdx(gaps[0][0], true);\n\n            if (yData[firstIdx - 1] == null) {\n              filtered.push(firstIdx);\n            }\n\n            // show single points between consecutive gaps that share end/start\n            for (let i = 0; i < gaps.length; i++) {\n              let thisGap = gaps[i];\n              let nextGap = gaps[i + 1];\n\n              if (nextGap && thisGap[1] === nextGap[0]) {\n                // approx when data density is > 1pt/px, since gap start/end pixels are rounded\n                let approxIdx = u.posToIdx(thisGap[1], true);\n\n                if (yData[approxIdx] == null) {\n                  // scan left/right alternating to find closest index with non-null value\n                  for (let j = 1; j < 100; j++) {\n                    if (yData[approxIdx + j] != null) {\n                      approxIdx += j;\n                      break;\n                    }\n                    if (yData[approxIdx - j] != null) {\n                      approxIdx -= j;\n                      break;\n                    }\n                  }\n                }\n\n                filtered.push(approxIdx);\n              }\n            }\n\n            const lastIdx = u.posToIdx(gaps[gaps.length - 1][1], true);\n\n            if (yData[lastIdx + 1] == null) {\n              filtered.push(lastIdx);\n            }\n          }\n          // single point\n          else {\n            // scan right\n            let leftIdx = 0;\n            while (yData[leftIdx] === null) {\n              leftIdx++;\n            }\n\n            // scan left\n            let rightIdx = yData.length - 1;\n            while (rightIdx >= leftIdx && yData[rightIdx] === null) {\n              rightIdx--;\n            }\n\n            // render if same\n            if (leftIdx === rightIdx) {\n              filtered.push(leftIdx);\n            }\n          }\n        }\n\n        return filtered.length ? filtered : null;\n      };\n    }\n\n    let { fillOpacity } = customConfig;\n\n    let pathBuilder: uPlot.Series.PathBuilder | null = null;\n    let pointsBuilder: uPlot.Series.Points.Show | null = null;\n\n    if (field.state?.origin) {\n      if (!indexByName) {\n        indexByName = getNamesToFieldIndex(frame, allFrames);\n      }\n\n      const originFrame = allFrames[field.state.origin.frameIndex];\n      const originField = originFrame?.fields[field.state.origin.fieldIndex];\n\n      const dispName = getFieldDisplayName(originField ?? field, originFrame, allFrames);\n\n      // disable default renderers\n      if (customRenderedFields.indexOf(dispName) >= 0) {\n        pathBuilder = () => null;\n        pointsBuilder = () => undefined;\n      } else if (customConfig.transform === GraphTransform.Constant) {\n        // patch some monkeys!\n        const defaultBuilder = uPlot.paths!.linear!();\n\n        pathBuilder = (u, seriesIdx) => {\n          //eslint-disable-next-line\n          const _data: any[] = (u as any)._data; // uplot.AlignedData not exposed in types\n\n          // the data we want the line renderer to pull is x at each plot edge with paired flat y values\n\n          const r = getTimeRange();\n          let xData = [r.from.valueOf(), r.to.valueOf()];\n          let firstY = _data[seriesIdx].find((v: number | null | undefined) => v != null);\n          let yData = [firstY, firstY];\n          let fauxData = _data.slice();\n          fauxData[0] = xData;\n          fauxData[seriesIdx] = yData;\n\n          //eslint-disable-next-line\n          return defaultBuilder(\n            {\n              ...u,\n              _data: fauxData,\n            } as any,\n            seriesIdx,\n            0,\n            1\n          );\n        };\n      }\n\n      if (customConfig.fillBelowTo) {\n        const fillBelowToField = frame.fields.find(\n          (f) =>\n            customConfig.fillBelowTo === f.name ||\n            customConfig.fillBelowTo === f.config?.displayNameFromDS ||\n            customConfig.fillBelowTo === getFieldDisplayName(f, frame, allFrames)\n        );\n\n        const fillBelowDispName = fillBelowToField\n          ? getFieldDisplayName(fillBelowToField, frame, allFrames)\n          : customConfig.fillBelowTo;\n\n        const t = indexByName.get(dispName);\n        const b = indexByName.get(fillBelowDispName);\n        if (isNumber(b) && isNumber(t)) {\n          builder.addBand({\n            series: [t, b],\n            fill: undefined, // using null will have the band use fill options from `t`\n          });\n\n          if (!fillOpacity) {\n            fillOpacity = 35; // default from flot\n          }\n        } else {\n          fillOpacity = 0;\n        }\n      }\n    }\n\n    let dynamicSeriesColor: ((seriesIdx: number) => string | undefined) | undefined = undefined;\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      dynamicSeriesColor = (seriesIdx) => getFieldSeriesColor(alignedFrame.fields[seriesIdx], theme).color;\n    }\n\n    builder.addSeries({\n      pathBuilder,\n      pointsBuilder,\n      scaleKey,\n      showPoints,\n      pointsFilter,\n      colorMode,\n      fillOpacity,\n      theme,\n      dynamicSeriesColor,\n      drawStyle: customConfig.drawStyle!,\n      lineColor: customConfig.lineColor ?? seriesColor,\n      lineWidth: customConfig.lineWidth,\n      lineInterpolation: customConfig.lineInterpolation,\n      lineStyle: customConfig.lineStyle,\n      barAlignment: customConfig.barAlignment,\n      barWidthFactor: customConfig.barWidthFactor,\n      barMaxWidth: customConfig.barMaxWidth,\n      pointSize: customConfig.pointSize,\n      spanNulls: customConfig.spanNulls || false,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n      showValues: customConfig.showValues,\n    });\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphThresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphThresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  const mightShowValues = frame.fields.some((field, i) => {\n    if (i === 0) {\n      return false;\n    }\n\n    const customConfig = field.config.custom ?? {};\n\n    return (\n      customConfig.showValues &&\n      (customConfig.drawStyle === GraphDrawStyle.Points || customConfig.showPoints !== VisibilityMode.Never)\n    );\n  });\n\n  if (mightShowValues) {\n    // since bars style doesnt show points in Auto mode, we can't piggyback on series.points.show()\n    // so we make a simple density-based callback to use here\n    const barsShowValues = (u: uPlot) => {\n      let width = u.bbox.width / uPlot.pxRatio;\n      let count = u.data[0].length;\n\n      // render values when each has at least 30px of width available\n      return width / count >= 30;\n    };\n\n    builder.addHook('draw', (u: uPlot) => {\n      const baseFontSize = 12;\n      const font = `${baseFontSize * uPlot.pxRatio}px ${theme.typography.fontFamily}`;\n\n      const { ctx } = u;\n\n      ctx.save();\n      ctx.fillStyle = theme.colors.text.primary;\n      ctx.font = font;\n      ctx.textAlign = 'center';\n\n      for (let seriesIdx = 1; seriesIdx < u.data.length; seriesIdx++) {\n        const series = u.series[seriesIdx];\n        const field = frame.fields[seriesIdx];\n\n        if (\n          field.config.custom?.showValues &&\n          // @ts-ignore points.show() is always callable on the instance (but may be boolean when passed to uPlot as init option)\n          (series.points?.show?.(u, seriesIdx) ||\n            (field.config.custom?.drawStyle === DrawStyle.Bars && barsShowValues(u)))\n        ) {\n          const xData = u.data[0];\n          const yData = u.data[seriesIdx];\n          const yScale = series.scale!;\n\n          for (let dataIdx = 0; dataIdx < yData.length; dataIdx++) {\n            const yVal = yData[dataIdx];\n\n            if (yVal != null) {\n              const text = formattedValueToString(field.display!(yVal));\n\n              const isNegative = yVal < 0;\n              const textOffset = isNegative ? 15 : -5;\n              ctx.textBaseline = isNegative ? 'top' : 'bottom';\n\n              const xVal = xData[dataIdx];\n              const x = u.valToPos(xVal, 'x', true);\n              const y = u.valToPos(yVal, yScale, true);\n\n              ctx.fillText(text, x, y + textOffset);\n            }\n          }\n        }\n      }\n\n      ctx.restore();\n    });\n  }\n\n  // hook up custom/composite renderers\n  renderers?.forEach((r) => {\n    if (!indexByName) {\n      indexByName = getNamesToFieldIndex(frame, allFrames);\n    }\n    let fieldIndices: Record<string, number> = {};\n\n    for (let key in r.fieldMap) {\n      let dispName = r.fieldMap[key];\n      fieldIndices[key] = indexByName.get(dispName)!;\n    }\n\n    r.init(builder, fieldIndices);\n  });\n\n  // if hovered value is null, how far we may scan left/right to hover nearest non-null\n  const DEFAULT_HOVER_NULL_PROXIMITY = 15;\n  const DEFAULT_FOCUS_PROXIMITY = 30;\n\n  let cursor: Partial<uPlot.Cursor> = {\n    // horizontal proximity / point hover behavior\n    hover: {\n      prox: (self, seriesIdx, hoveredIdx) => {\n        if (hoverProximity != null) {\n          return hoverProximity;\n        }\n\n        // when hovering null values, scan data left/right up to 15px\n        const yVal = self.data[seriesIdx][hoveredIdx];\n        if (yVal === null) {\n          return DEFAULT_HOVER_NULL_PROXIMITY;\n        }\n\n        // no proximity limit\n        return null;\n      },\n      skip: [null],\n    },\n    // vertical proximity / series focus behavior\n    focus: {\n      prox: hoverProximity ?? DEFAULT_FOCUS_PROXIMITY,\n    },\n    points: { one: true },\n  };\n\n  builder.setCursor(cursor);\n\n  return builder;\n};\n\nfunction getNamesToFieldIndex(frame: DataFrame, allFrames: DataFrame[]): Map<string, number> {\n  const originNames = new Map<string, number>();\n  frame.fields.forEach((field, i) => {\n    const origin = field.state?.origin;\n    if (origin) {\n      const origField = allFrames[origin.frameIndex]?.fields[origin.fieldIndex];\n      if (origField) {\n        originNames.set(getFieldDisplayName(origField, allFrames[origin.frameIndex], allFrames), i);\n      }\n    }\n  });\n  return originNames;\n}\n","import { Component } from 'react';\n\nimport { DataFrame, TimeRange } from '@grafana/data';\nimport { withTheme2 } from '@grafana/ui';\nimport { hasVisibleLegendSeries, PlotLegend, UPlotConfigBuilder } from '@grafana/ui/internal';\n\nimport { GraphNG, GraphNGProps, PropDiffFn } from '../GraphNG/GraphNG';\n\nimport { preparePlotConfigBuilder } from './utils';\n\nconst propsToDiff: Array<string | PropDiffFn> = ['legend', 'options', 'theme'];\n\ntype TimeSeriesProps = Omit<GraphNGProps, 'prepConfig' | 'propsToDiff' | 'renderLegend'>;\n\nexport class UnthemedTimeSeries extends Component<TimeSeriesProps> {\n  prepConfig = (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => {\n    const { theme, timeZone, options, renderers, tweakAxis, tweakScale } = this.props;\n\n    return preparePlotConfigBuilder({\n      frame: alignedFrame,\n      theme,\n      timeZones: Array.isArray(timeZone) ? timeZone : [timeZone],\n      getTimeRange,\n      allFrames,\n      renderers,\n      tweakScale,\n      tweakAxis,\n      hoverProximity: options?.tooltip?.hoverProximity,\n      orientation: options?.orientation,\n    });\n  };\n\n  renderLegend = (config: UPlotConfigBuilder) => {\n    const { legend, frames } = this.props;\n\n    if (!config || (legend && !legend.showLegend) || !hasVisibleLegendSeries(config, frames)) {\n      return null;\n    }\n\n    return <PlotLegend data={frames} config={config} {...legend} />;\n  };\n\n  render() {\n    return (\n      <GraphNG\n        {...this.props}\n        prepConfig={this.prepConfig}\n        propsToDiff={propsToDiff}\n        renderLegend={this.renderLegend}\n      />\n    );\n  }\n}\n\nexport const TimeSeries = withTheme2(UnthemedTimeSeries);\nTimeSeries.displayName = 'TimeSeries';\n","import { Component } from 'react';\nimport * as React from 'react';\nimport uPlot, { AlignedData } from 'uplot';\n\nimport {\n  DataFrame,\n  DataLinkPostProcessor,\n  Field,\n  FieldMatcherID,\n  fieldMatchers,\n  FieldType,\n  getLinksSupplier,\n  InterpolateFunction,\n  TimeRange,\n  TimeZone,\n} from '@grafana/data';\nimport { DashboardCursorSync, VizLegendOptions } from '@grafana/schema';\nimport { Themeable2, VizLayout } from '@grafana/ui';\nimport { UPlotChart, AxisProps, Renderers, UPlotConfigBuilder, ScaleProps, pluginLog } from '@grafana/ui/internal';\n\nimport { GraphNGLegendEvent, XYFieldMatchers } from './types';\nimport { preparePlotFrame as defaultPreparePlotFrame } from './utils';\n\n/**\n * @internal -- not a public API\n */\nexport type PropDiffFn<T extends Record<string, unknown> = {}> = (prev: T, next: T) => boolean;\n\nexport interface GraphNGProps extends Themeable2 {\n  frames: DataFrame[];\n  structureRev?: number; // a number that will change when the frames[] structure changes\n  width: number;\n  height: number;\n  timeRange: TimeRange;\n  timeZone: TimeZone[] | TimeZone;\n  legend: VizLegendOptions;\n  fields?: XYFieldMatchers; // default will assume timeseries data\n  renderers?: Renderers;\n  tweakScale?: (opts: ScaleProps, forField: Field) => ScaleProps;\n  tweakAxis?: (opts: AxisProps, forField: Field) => AxisProps;\n  onLegendClick?: (event: GraphNGLegendEvent) => void;\n  children?: (builder: UPlotConfigBuilder, alignedFrame: DataFrame) => React.ReactNode;\n  prepConfig: (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => UPlotConfigBuilder;\n  propsToDiff?: Array<string | PropDiffFn>;\n  preparePlotFrame?: (frames: DataFrame[], dimFields: XYFieldMatchers) => DataFrame | null;\n  renderLegend: (config: UPlotConfigBuilder) => React.ReactElement | null;\n  replaceVariables: InterpolateFunction;\n  dataLinkPostProcessor?: DataLinkPostProcessor;\n  cursorSync?: DashboardCursorSync;\n\n  // Remove fields that are hidden from the visualization before rendering\n  // The fields will still be available for other things like data links\n  // this is a temporary hack that only works when:\n  // 1. renderLegend (above) does not render <PlotLegend>\n  // 2. does not have legend series toggle\n  // 3. passes through all fields required for link/action gen (including those with hideFrom.viz)\n  omitHideFromViz?: boolean;\n\n  /**\n   * needed for propsToDiff to re-init the plot & config\n   * this is a generic approach to plot re-init, without having to specify which panel-level options\n   * should cause invalidation. we can drop this in favor of something like panelOptionsRev that gets passed in\n   * similar to structureRev. then we can drop propsToDiff entirely.\n   */\n  options?: Record<string, any>;\n}\n\nfunction sameProps<T extends Record<string, unknown>>(\n  prevProps: T,\n  nextProps: T,\n  propsToDiff: Array<string | PropDiffFn> = []\n) {\n  for (const propName of propsToDiff) {\n    if (typeof propName === 'function') {\n      if (!propName(prevProps, nextProps)) {\n        return false;\n      }\n    } else if (nextProps[propName] !== prevProps[propName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @internal -- not a public API\n */\nexport interface GraphNGState {\n  alignedFrame: DataFrame;\n  alignedData?: AlignedData;\n  config?: UPlotConfigBuilder;\n}\n\nconst defaultMatchers = {\n  x: fieldMatchers.get(FieldMatcherID.firstTimeField).get({}),\n  y: fieldMatchers.get(FieldMatcherID.byTypes).get(new Set([FieldType.number, FieldType.enum])),\n};\n\n/**\n * \"Time as X\" core component, expects ascending x\n */\nexport class GraphNG extends Component<GraphNGProps, GraphNGState> {\n  private plotInstance: React.RefObject<uPlot>;\n\n  constructor(props: GraphNGProps) {\n    super(props);\n    let state = this.prepState(props);\n    state.alignedData = state.config!.prepData!([state.alignedFrame]) as AlignedData;\n    this.state = state;\n    this.plotInstance = React.createRef();\n  }\n\n  getTimeRange = () => this.props.timeRange;\n\n  prepState(props: GraphNGProps, withConfig = true) {\n    let state: GraphNGState = null as any;\n\n    const { frames, fields = defaultMatchers, preparePlotFrame, replaceVariables, dataLinkPostProcessor } = props;\n\n    const preparePlotFrameFn = preparePlotFrame ?? defaultPreparePlotFrame;\n\n    const withLinks = frames.some((frame) => frame.fields.some((field) => (field.config.links?.length ?? 0) > 0));\n\n    const alignedFrame = preparePlotFrameFn(\n      frames,\n      {\n        ...fields,\n        // if there are data links, keep all fields during join so they're index-matched\n        y: withLinks ? () => true : fields.y,\n      },\n      props.timeRange\n    );\n\n    pluginLog('GraphNG', false, 'data aligned', alignedFrame);\n\n    if (alignedFrame) {\n      let alignedFrameFinal = alignedFrame;\n\n      if (withLinks) {\n        const timeZone = Array.isArray(this.props.timeZone) ? this.props.timeZone[0] : this.props.timeZone;\n\n        // for links gen we need to use original frames but with the aligned/joined data values\n        let linkFrames = frames.map((frame, frameIdx) => ({\n          ...frame,\n          fields: alignedFrame.fields.filter(\n            (field, fieldIdx) => fieldIdx === 0 || field.state?.origin?.frameIndex === frameIdx\n          ),\n          length: alignedFrame.length,\n        }));\n\n        linkFrames.forEach((linkFrame, frameIndex) => {\n          linkFrame.fields.forEach((field) => {\n            field.getLinks = getLinksSupplier(\n              linkFrame,\n              field,\n              {\n                ...field.state?.scopedVars,\n                __dataContext: {\n                  value: {\n                    data: linkFrames,\n                    field: field,\n                    frame: linkFrame,\n                    frameIndex,\n                  },\n                },\n              },\n              replaceVariables,\n              timeZone,\n              dataLinkPostProcessor\n            );\n          });\n        });\n\n        // filter join field and fields.y\n        alignedFrameFinal = {\n          ...alignedFrame,\n          fields: alignedFrame.fields.filter((field, i) => i === 0 || fields.y(field, alignedFrame, [alignedFrame])),\n        };\n      }\n\n      if (props.omitHideFromViz) {\n        const nonHiddenFields = alignedFrameFinal.fields.filter((field) => field.config.custom?.hideFrom?.viz !== true);\n        alignedFrameFinal = {\n          ...alignedFrameFinal,\n          fields: nonHiddenFields,\n          length: nonHiddenFields.length,\n        };\n      }\n\n      let config = this.state?.config;\n\n      if (withConfig) {\n        config = props.prepConfig(alignedFrameFinal, this.props.frames, this.getTimeRange);\n        pluginLog('GraphNG', false, 'config prepared', config);\n      }\n\n      state = {\n        alignedFrame: alignedFrameFinal,\n        config,\n      };\n\n      pluginLog('GraphNG', false, 'data prepared', state.alignedData);\n    }\n\n    return state;\n  }\n\n  componentDidUpdate(prevProps: GraphNGProps) {\n    const { frames, structureRev, timeZone, cursorSync, propsToDiff } = this.props;\n\n    const propsChanged = !sameProps(prevProps, this.props, propsToDiff);\n\n    if (\n      frames !== prevProps.frames ||\n      propsChanged ||\n      timeZone !== prevProps.timeZone ||\n      cursorSync !== prevProps.cursorSync\n    ) {\n      let newState = this.prepState(this.props, false);\n\n      if (newState) {\n        const shouldReconfig =\n          this.state.config === undefined ||\n          timeZone !== prevProps.timeZone ||\n          cursorSync !== prevProps.cursorSync ||\n          structureRev !== prevProps.structureRev ||\n          !structureRev ||\n          propsChanged;\n\n        if (shouldReconfig) {\n          newState.config = this.props.prepConfig(newState.alignedFrame, this.props.frames, this.getTimeRange);\n          pluginLog('GraphNG', false, 'config recreated', newState.config);\n        }\n\n        newState.alignedData = newState.config!.prepData!([newState.alignedFrame]) as AlignedData;\n\n        this.setState(newState);\n      }\n    }\n  }\n\n  render() {\n    const { width, height, children, renderLegend } = this.props;\n    const { config, alignedFrame, alignedData } = this.state;\n\n    if (!config) {\n      return null;\n    }\n\n    return (\n      <VizLayout width={width} height={height} legend={renderLegend(config)}>\n        {(vizWidth: number, vizHeight: number) => (\n          <UPlotChart\n            config={config}\n            data={alignedData!}\n            width={vizWidth}\n            height={vizHeight}\n            plotRef={(u) => ((this.plotInstance as React.MutableRefObject<uPlot>).current = u)}\n          >\n            {children ? children(config, alignedFrame) : null}\n          </UPlotChart>\n        )}\n      </VizLayout>\n    );\n  }\n}\n","import { ReactNode } from 'react';\n\nimport { DataFrame, Field, FieldType, formattedValueToString, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport {\n  VizTooltipContent,\n  VizTooltipFooter,\n  VizTooltipHeader,\n  VizTooltipWrapper,\n  getContentItems,\n  VizTooltipItem,\n  AdHocFilterModel,\n} from '@grafana/ui/internal';\n\nimport { getFieldActions } from '../status-history/utils';\n\nimport { isTooltipScrollable } from './utils';\n\n// exemplar / annotation / time region hovering?\n// add annotation UI / alert dismiss UI?\n\nexport interface TimeSeriesTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n\n  // aligned fields that are not series\n  _rest?: Field[];\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n\n  annotate?: () => void;\n  maxHeight?: number;\n\n  replaceVariables?: InterpolateFunction;\n  dataLinks: LinkModel[];\n  hideZeros?: boolean;\n  adHocFilters?: AdHocFilterModel[];\n  canExecuteActions?: boolean;\n  compareDiffMs?: number[];\n}\n\nexport const TimeSeriesTooltip = ({\n  series,\n  _rest,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  maxHeight,\n  replaceVariables = (str) => str,\n  dataLinks,\n  hideZeros,\n  adHocFilters,\n  canExecuteActions,\n  compareDiffMs,\n}: TimeSeriesTooltipProps) => {\n  const xField = series.fields[0];\n\n  let xVal = xField.values[dataIdxs[0]!];\n\n  if (compareDiffMs != null && xField.type === FieldType.time) {\n    xVal += compareDiffMs[seriesIdx ?? 1];\n  }\n\n  const xDisp = formattedValueToString(xField.display!(xVal));\n\n  const contentItems = getContentItems(\n    series.fields,\n    xField,\n    dataIdxs,\n    seriesIdx,\n    mode,\n    sortOrder,\n    (field) => field.type === FieldType.number || field.type === FieldType.enum,\n    hideZeros,\n    _rest\n  );\n\n  let footer: ReactNode;\n\n  if (seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const hasOneClickLink = dataLinks.some((dataLink) => dataLink.oneClick === true);\n\n    if (isPinned || hasOneClickLink) {\n      const dataIdx = dataIdxs[seriesIdx]!;\n      const actions = canExecuteActions ? getFieldActions(series, field, replaceVariables, dataIdx) : [];\n\n      footer = (\n        <VizTooltipFooter dataLinks={dataLinks} actions={actions} annotate={annotate} adHocFilters={adHocFilters} />\n      );\n    }\n  }\n\n  const headerItem: VizTooltipItem = {\n    label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n    value: xDisp,\n  };\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n"],"names":["getDataLinks","field","rowIdx","links","v","disp","linkLookup","link","key","getAllFrameActions","dataFrame","getFieldActions","replaceVars","rowIndex","actions","actionLookup","action","nullToUndefThreshold","refValues","fieldValues","maxThreshold","prevRef","nullIdx","i","isVisibleBarField","f","getRefField","frame","refFieldName","applySpanNullsThresholds","refField","spanNulls","getXField","dimFields","frames","preparePlotFrame","timeRange","xField","numBarSeries","acc","minXDeltaGlobal","minXDeltas","minXDeltaFrame","xVals","alignedFrame","fi","vals","lastVal","IEC_UNITS","BIN_INCRS","defaultFormatter","decimals","defaultConfig","preparePlotConfigBuilder","theme","timeZones","getTimeRange","allFrames","renderers","tweakScale","opts","tweakAxis","hoverProximity","orientation","isHorizontal","builder","UPlotConfigBuilder","xScaleKey","yScaleKey","xFieldAxisPlacement","xFieldAxisShow","r","filterTicks","u","splits","timeZone","a","cssBaseline","custom","scaleDistr","customRenderedFields","name","indexByName","config","customConfig","fmt","scaleKey","colorMode","seriesColor","dataMin","dataMax","axisColor","axisDisplayOptions","incrs","values","text","showPoints","pointsFilter","seriesIdx","show","gaps","filtered","yData","firstIdx","thisGap","nextGap","approxIdx","j","lastIdx","leftIdx","rightIdx","fillOpacity","pathBuilder","pointsBuilder","getNamesToFieldIndex","originFrame","originField","dispName","defaultBuilder","_data","xData","firstY","fauxData","fillBelowToField","fillBelowDispName","t","b","dynamicSeriesColor","stackingGroups","barsShowValues","width","count","font","ctx","series","yScale","dataIdx","yVal","isNegative","textOffset","xVal","x","y","fieldIndices","DEFAULT_HOVER_NULL_PROXIMITY","cursor","self","hoveredIdx","originNames","origin","origField","propsToDiff","UnthemedTimeSeries","options","legend","PlotLegend","GraphNG","TimeSeries","sameProps","prevProps","nextProps","propName","defaultMatchers","props","state","withConfig","fields","replaceVariables","dataLinkPostProcessor","preparePlotFrameFn","withLinks","alignedFrameFinal","linkFrames","frameIdx","fieldIdx","linkFrame","frameIndex","nonHiddenFields","structureRev","cursorSync","propsChanged","newState","height","children","renderLegend","alignedData","vizWidth","vizHeight","TimeSeriesTooltip","_rest","dataIdxs","mode","sortOrder","isPinned","annotate","maxHeight","str","dataLinks","hideZeros","adHocFilters","canExecuteActions","compareDiffMs","xDisp","contentItems","footer","hasOneClickLink","dataLink","headerItem"],"sourceRoot":""}