{"version":3,"file":"3474.74dfd856a9528c758a57.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/nodeGraph/utils.ts","webpack://grafana/./public/app/plugins/panel/nodeGraph/Node.tsx"],"sourcesContent":["import {\n  DataFrame,\n  Field,\n  FieldCache,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  MutableDataFrame,\n  NodeGraphDataFrameFieldNames,\n} from '@grafana/data';\n\nimport { nodeR } from './Node';\nimport { EdgeDatum, GraphFrame, NodeDatum, NodeDatumFromEdge, NodeGraphOptions } from './types';\n\ntype Line = { x1: number; y1: number; x2: number; y2: number };\n\n/**\n * Makes line shorter while keeping its middle in the same place.\n * This is manly used to add some empty space between an edge line and its source and target nodes, to make it nicer.\n *\n * @param line a line, where x1 and y1 are the coordinates of the source node center, and x2 and y2 are the coordinates of the target node center\n * @param sourceNodeRadius radius of the source node (possibly taking into account the thickness of the node circumference line, etc.)\n * @param targetNodeRadius radius of the target node (possibly taking into account the thickness of the node circumference line, etc.)\n * @param arrowHeadHeight height of the arrow head (in pixels)\n */\nexport function shortenLine(line: Line, sourceNodeRadius: number, targetNodeRadius: number, arrowHeadHeight = 1): Line {\n  const vx = line.x2 - line.x1;\n  const vy = line.y2 - line.y1;\n  const mag = Math.sqrt(vx * vx + vy * vy);\n  const cosine = (line.x2 - line.x1) / mag;\n  const sine = (line.y2 - line.y1) / mag;\n  const scaledThickness = arrowHeadHeight - arrowHeadHeight / 10;\n\n  // Reduce the line length (along its main direction) by:\n  // - the radius of the source node\n  // - the radius of the target node,\n  // - a constant value, just to add some empty space\n  // - the height of the arrow head; the bigger the arrow head, the better is to add even more empty space\n  return {\n    x1: line.x1 + cosine * (sourceNodeRadius + 5),\n    y1: line.y1 + sine * (sourceNodeRadius + 5),\n    x2: line.x2 - cosine * (targetNodeRadius + 3 + scaledThickness),\n    y2: line.y2 - sine * (targetNodeRadius + 3 + scaledThickness),\n  };\n}\n\nexport type NodeFields = {\n  fixedX?: Field;\n  fixedY?: Field;\n  id?: Field;\n  title?: Field;\n  subTitle?: Field;\n  mainStat?: Field;\n  secondaryStat?: Field;\n  arc: Field[];\n  details: Field[];\n  color?: Field;\n  icon?: Field;\n  nodeRadius?: Field;\n  highlighted?: Field;\n  isInstrumented?: Field;\n};\n\nexport function getNodeFields(nodes: DataFrame): NodeFields {\n  const normalizedFrames = {\n    ...nodes,\n    fields: nodes.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    title: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.title.toLowerCase()),\n    subTitle: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.subTitle.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    arc: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.arc),\n    details: findFieldsByPrefix(nodes, NodeGraphDataFrameFieldNames.detail),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color),\n    icon: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.icon),\n    nodeRadius: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.nodeRadius.toLowerCase()),\n    highlighted: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),\n    fixedX: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.fixedX.toLowerCase()),\n    fixedY: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.fixedY.toLowerCase()),\n    isInstrumented: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.isInstrumented.toLowerCase()),\n  };\n}\n\nexport type EdgeFields = {\n  id?: Field;\n  source?: Field;\n  target?: Field;\n  mainStat?: Field;\n  secondaryStat?: Field;\n  details: Field[];\n  /**\n   * @deprecated use `color` instead\n   */\n  highlighted?: Field;\n  thickness?: Field;\n  color?: Field;\n  strokeDasharray?: Field;\n};\n\nexport function getEdgeFields(edges: DataFrame): EdgeFields {\n  const normalizedFrames = {\n    ...edges,\n    fields: edges.fields.map((field) => ({ ...field, name: field.name.toLowerCase() })),\n  };\n  const fieldsCache = new FieldCache(normalizedFrames);\n  return {\n    id: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id.toLowerCase()),\n    source: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase()),\n    target: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.target.toLowerCase()),\n    mainStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.mainStat.toLowerCase()),\n    secondaryStat: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.secondaryStat.toLowerCase()),\n    details: findFieldsByPrefix(edges, NodeGraphDataFrameFieldNames.detail.toLowerCase()),\n    // @deprecated -- for edges use color instead\n    highlighted: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.highlighted.toLowerCase()),\n    thickness: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.thickness.toLowerCase()),\n    color: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.color.toLowerCase()),\n    strokeDasharray: fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.strokeDasharray.toLowerCase()),\n  };\n}\n\nfunction findFieldsByPrefix(frame: DataFrame, prefix: string): Field[] {\n  return frame.fields.filter((f) => f.name.match(new RegExp('^' + prefix)));\n}\n\n/**\n * Transform nodes and edges dataframes into array of objects that the layout code can then work with.\n */\nexport function processNodes(\n  nodes: DataFrame | undefined,\n  edges: DataFrame | undefined\n): {\n  nodes: NodeDatum[];\n  edges: EdgeDatum[];\n  hasFixedPositions?: boolean;\n  legend?: Array<{\n    color: string;\n    name: string;\n  }>;\n} {\n  if (!(edges || nodes)) {\n    return { nodes: [], edges: [] };\n  }\n\n  if (nodes) {\n    const nodeFields = getNodeFields(nodes);\n    if (!nodeFields.id) {\n      throw new Error('id field is required for nodes data frame.');\n    }\n\n    const hasFixedPositions =\n      nodeFields.fixedX &&\n      nodeFields.fixedX.values.every((v) => Number.isFinite(v)) &&\n      nodeFields.fixedY &&\n      nodeFields.fixedY.values.every((v) => Number.isFinite(v));\n\n    // Throw an error if somebody is using fixedX and fixedY fields incorrectly. Other option is to ignore this but we\n    // are not able to easily combine fixed and non-fixed position in layout so that behaviour would be undefined\n    // and silent.\n    if (!hasFixedPositions) {\n      const somePosFilled =\n        (nodeFields.fixedX && nodeFields.fixedX.values.some((v) => Number.isFinite(v))) ||\n        (nodeFields.fixedY && nodeFields.fixedY.values.some((v) => Number.isFinite(v)));\n      if (somePosFilled) {\n        throw new Error('If fixedX and fixedY fields are present, the values have to be all filled and valid');\n      }\n    }\n\n    // Create the nodes here\n    const nodesMap: { [id: string]: NodeDatum } = {};\n    for (let i = 0; i < nodeFields.id.values.length; i++) {\n      const id = nodeFields.id.values[i];\n      nodesMap[id] = makeNodeDatum(id, nodeFields, i);\n    }\n\n    // We may not have edges in case of single node\n    let edgeDatums: EdgeDatum[] = edges ? processEdges(edges, getEdgeFields(edges), nodesMap) : [];\n\n    for (const e of edgeDatums) {\n      // We are adding incoming edges count, so we can later on find out which nodes are the roots\n      nodesMap[e.target].incoming++;\n    }\n\n    return {\n      nodes: Object.values(nodesMap),\n      edges: edgeDatums,\n      hasFixedPositions,\n      legend: nodeFields.arc.map((f) => {\n        return {\n          color: f.config.color?.fixedColor ?? '',\n          name: f.config.displayName || f.name,\n        };\n      }),\n    };\n  } else {\n    // We have only edges here, so we have to construct also nodes out of them\n\n    // We checked that either node || edges has to be defined and if nodes aren't edges has to be defined\n    edges = edges!;\n\n    const nodesMap: { [id: string]: NodeDatumFromEdge } = {};\n\n    const edgeFields = getEdgeFields(edges);\n\n    // Turn edges into reasonable filled in nodes\n    for (let i = 0; i < edges.length; i++) {\n      const { source, target } = makeNodeDatumsFromEdge(edgeFields, i);\n\n      nodesMap[target.id] = nodesMap[target.id] || target;\n      nodesMap[source.id] = nodesMap[source.id] || source;\n\n      // Check the stats fields. They can be also strings which we cannot really aggregate so only aggregate in case\n      // they are numbers. Here we just sum all incoming edges to get the final value for node.\n      if (computableField(edgeFields.mainStat)) {\n        nodesMap[target.id].mainStatNumeric =\n          (nodesMap[target.id].mainStatNumeric ?? 0) + edgeFields.mainStat!.values[i];\n      }\n\n      if (computableField(edgeFields.secondaryStat)) {\n        nodesMap[target.id].secondaryStatNumeric =\n          (nodesMap[target.id].secondaryStatNumeric ?? 0) + edgeFields.secondaryStat!.values[i];\n      }\n\n      // We are adding incoming edges count, so we can later on find out which nodes are the roots\n      nodesMap[target.id].incoming++;\n    }\n\n    let edgeDatums = processEdges(edges, edgeFields, nodesMap);\n\n    // It is expected for stats to be Field, so we have to create them.\n    const nodes = normalizeStatsForNodes(nodesMap, edgeFields);\n\n    return {\n      nodes,\n      edges: edgeDatums,\n      // Edge-only datasets never have fixedX/fixedY\n      hasFixedPositions: false,\n    };\n  }\n}\n\n/**\n * Turn data frame data into EdgeDatum that node graph understands\n * @param edges\n * @param edgeFields\n */\nfunction processEdges(edges: DataFrame, edgeFields: EdgeFields, nodesMap: { [id: string]: NodeDatum }): EdgeDatum[] {\n  if (!edgeFields.id) {\n    throw new Error('id field is required for edges data frame.');\n  }\n\n  return edgeFields.id.values.map((id, index) => {\n    const target = edgeFields.target?.values[index];\n    const source = edgeFields.source?.values[index];\n\n    const sourceNode = nodesMap[source];\n    const targetNode = nodesMap[target];\n\n    return {\n      id,\n      dataFrameRowIndex: index,\n      source,\n      target,\n      sourceNodeRadius: !sourceNode.nodeRadius ? nodeR : sourceNode.nodeRadius.values[sourceNode.dataFrameRowIndex],\n      targetNodeRadius: !targetNode.nodeRadius ? nodeR : targetNode.nodeRadius.values[targetNode.dataFrameRowIndex],\n      mainStat: edgeFields.mainStat ? statToString(edgeFields.mainStat.config, edgeFields.mainStat.values[index]) : '',\n      secondaryStat: edgeFields.secondaryStat\n        ? statToString(edgeFields.secondaryStat.config, edgeFields.secondaryStat.values[index])\n        : '',\n      // @deprecated -- for edges use color instead\n      highlighted: edgeFields.highlighted?.values[index] || false,\n      thickness: edgeFields.thickness?.values[index] || 1,\n      color: edgeFields.color?.values[index],\n      strokeDasharray: edgeFields.strokeDasharray?.values[index],\n    };\n  });\n}\n\nfunction computableField(field?: Field) {\n  return field && field.type === FieldType.number;\n}\n\n/**\n * Instead of just simple numbers node graph requires to have Field in NodeDatum (probably for some formatting info in\n * config). So we create them here and fill with correct data.\n * @param nodesMap\n * @param edgeFields\n */\nfunction normalizeStatsForNodes(nodesMap: { [id: string]: NodeDatumFromEdge }, edgeFields: EdgeFields): NodeDatum[] {\n  const secondaryStatValues: Array<number | undefined> = [];\n  const mainStatValues: Array<number | undefined> = [];\n  const secondaryStatField = computableField(edgeFields.secondaryStat)\n    ? {\n        ...edgeFields.secondaryStat!,\n        values: secondaryStatValues,\n      }\n    : undefined;\n\n  const mainStatField = computableField(edgeFields.mainStat)\n    ? {\n        ...edgeFields.mainStat!,\n        values: mainStatValues,\n      }\n    : undefined;\n\n  return Object.values(nodesMap).map((node, index) => {\n    if (mainStatField || secondaryStatField) {\n      const newNode = {\n        ...node,\n      };\n\n      if (mainStatField) {\n        newNode.mainStat = mainStatField;\n        mainStatValues.push(node.mainStatNumeric);\n        newNode.dataFrameRowIndex = index;\n      }\n\n      if (secondaryStatField) {\n        newNode.secondaryStat = secondaryStatField;\n        secondaryStatValues.push(node.secondaryStatNumeric);\n        newNode.dataFrameRowIndex = index;\n      }\n      return newNode;\n    }\n    return node;\n  });\n}\n\nfunction makeNodeDatumsFromEdge(edgeFields: EdgeFields, index: number) {\n  const targetId = edgeFields.target?.values[index];\n  const sourceId = edgeFields.source?.values[index];\n  return {\n    target: makeSimpleNodeDatum(targetId, index),\n    source: makeSimpleNodeDatum(sourceId, index),\n  };\n}\n\nfunction makeSimpleNodeDatum(name: string, index: number): NodeDatumFromEdge {\n  return {\n    id: name,\n    title: name,\n    subTitle: '',\n    dataFrameRowIndex: index,\n    incoming: 0,\n    arcSections: [],\n    highlighted: false,\n  };\n}\n\nfunction makeNodeDatum(id: string, nodeFields: NodeFields, index: number): NodeDatum {\n  return {\n    id: id,\n    title: nodeFields.title?.values[index] || '',\n    subTitle: nodeFields.subTitle?.values[index] || '',\n    dataFrameRowIndex: index,\n    incoming: 0,\n    mainStat: nodeFields.mainStat,\n    secondaryStat: nodeFields.secondaryStat,\n    arcSections: nodeFields.arc,\n    color: nodeFields.color,\n    icon: nodeFields.icon?.values[index] || '',\n    nodeRadius: nodeFields.nodeRadius,\n    highlighted: nodeFields.highlighted?.values[index] || false,\n    x: nodeFields.fixedX?.values[index] ?? undefined,\n    y: nodeFields.fixedY?.values[index] ?? undefined,\n    isInstrumented: nodeFields.isInstrumented?.values[index] ?? true,\n  };\n}\n\nexport function statToString(config: FieldConfig, value: number | string): string {\n  if (typeof value === 'string') {\n    return value;\n  } else {\n    const decimals = config.decimals || 2;\n    if (Number.isFinite(value)) {\n      return value.toFixed(decimals) + (config.unit ? ' ' + config.unit : '');\n    } else {\n      return '';\n    }\n  }\n}\n\n/**\n * Utilities mainly for testing\n */\n\nexport function makeNodesDataFrame(\n  count: number,\n  partialNodes: Array<Partial<Record<NodeGraphDataFrameFieldNames, unknown>>> = []\n) {\n  const frame = nodesFrame();\n  for (let i = 0; i < count; i++) {\n    frame.add(makeNode(i, partialNodes[i]));\n  }\n\n  return frame;\n}\n\nfunction makeNode(index: number, partialNode: Partial<Record<NodeGraphDataFrameFieldNames, unknown>> = {}) {\n  return {\n    id: index.toString(),\n    title: `service:${index}`,\n    subtitle: 'service',\n    arc__success: 0.5,\n    arc__errors: 0.5,\n    mainstat: 0.1,\n    secondarystat: 2,\n    color: 0.5,\n    icon: 'database',\n    noderadius: 40,\n    isinstrumented: true,\n    ...partialNode,\n  };\n}\n\nfunction nodesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.title]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.subTitle]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'success']: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.Fixed, fixedColor: 'green' } },\n    },\n    [NodeGraphDataFrameFieldNames.arc + 'errors']: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.Fixed, fixedColor: 'red' } },\n    },\n    [NodeGraphDataFrameFieldNames.color]: {\n      values: [],\n      type: FieldType.number,\n      config: { color: { mode: FieldColorModeId.ContinuousGrYlRd } },\n    },\n    [NodeGraphDataFrameFieldNames.icon]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.nodeRadius]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.isInstrumented]: {\n      values: [],\n      type: FieldType.boolean,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'nodes',\n    fields: Object.entries(fields).map(([key, value]) => ({\n      ...value,\n      name: key,\n    })),\n  });\n}\n\nexport function makeEdgesDataFrame(\n  edges: Array<Partial<{ source: string; target: string; mainstat: number; secondarystat: number }>>\n) {\n  const frame = edgesFrame();\n  for (const edge of edges) {\n    frame.add({\n      id: edge.source + '--' + edge.target,\n      ...edge,\n    });\n  }\n\n  return frame;\n}\n\nfunction edgesFrame() {\n  const fields = {\n    [NodeGraphDataFrameFieldNames.id]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.source]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.target]: {\n      values: [],\n      type: FieldType.string,\n    },\n    [NodeGraphDataFrameFieldNames.mainStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n    [NodeGraphDataFrameFieldNames.secondaryStat]: {\n      values: [],\n      type: FieldType.number,\n    },\n  };\n\n  return new MutableDataFrame({\n    name: 'edges',\n    fields: Object.entries(fields).map(([key, value]) => ({\n      ...value,\n      name: key,\n    })),\n  });\n}\n\nexport interface Bounds {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n  center: {\n    x: number;\n    y: number;\n  };\n}\n\n/**\n * Get bounds of the graph meaning the extent of the nodes in all directions.\n */\nexport function graphBounds(nodes: NodeDatum[]): Bounds {\n  if (nodes.length === 0) {\n    return { top: 0, right: 0, bottom: 0, left: 0, center: { x: 0, y: 0 } };\n  }\n\n  const bounds = nodes.reduce(\n    (acc, node) => {\n      if (node.x! > acc.right) {\n        acc.right = node.x!;\n      }\n      if (node.x! < acc.left) {\n        acc.left = node.x!;\n      }\n      if (node.y! > acc.bottom) {\n        acc.bottom = node.y!;\n      }\n      if (node.y! < acc.top) {\n        acc.top = node.y!;\n      }\n      return acc;\n    },\n    { top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity }\n  );\n\n  const y = bounds.top + (bounds.bottom - bounds.top) / 2;\n  const x = bounds.left + (bounds.right - bounds.left) / 2;\n\n  return {\n    ...bounds,\n    center: {\n      x,\n      y,\n    },\n  };\n}\n\nexport function getNodeGraphDataFrames(frames: DataFrame[], options?: NodeGraphOptions) {\n  // TODO: this not in sync with how other types of responses are handled. Other types have a query response\n  //  processing pipeline which ends up populating redux state with proper data. As we move towards more dataFrame\n  //  oriented API it seems like a better direction to move such processing into to visualisations and do minimal\n  //  and lazy processing here. Needs bigger refactor so keeping nodeGraph and Traces as they are for now.\n  let nodeGraphFrames = frames.filter((frame) => {\n    if (frame.meta?.preferredVisualisationType === 'nodeGraph') {\n      return true;\n    }\n\n    if (frame.name === 'nodes' || frame.name === 'edges' || frame.refId === 'nodes' || frame.refId === 'edges') {\n      return true;\n    }\n\n    const fieldsCache = new FieldCache(frame);\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.id)) {\n      return true;\n    }\n\n    return false;\n  });\n\n  // If panel options are provided, interpolate their values in to the data frames\n  if (options) {\n    nodeGraphFrames = applyOptionsToFrames(nodeGraphFrames, options);\n  }\n  return nodeGraphFrames;\n}\n\nexport const applyOptionsToFrames = (frames: DataFrame[], options: NodeGraphOptions): DataFrame[] => {\n  return frames.map((frame) => {\n    const fieldsCache = new FieldCache(frame);\n\n    // Edges frame has source which can be used to identify nodes vs edges frames\n    if (fieldsCache.getFieldByName(NodeGraphDataFrameFieldNames.source.toLowerCase())) {\n      if (options?.edges?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.mainStatUnit };\n        }\n      }\n      if (options?.edges?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.edges.secondaryStatUnit };\n        }\n      }\n    } else {\n      if (options?.nodes?.mainStatUnit) {\n        const field = frame.fields.find((field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.mainStat);\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.mainStatUnit };\n        }\n      }\n      if (options?.nodes?.secondaryStatUnit) {\n        const field = frame.fields.find(\n          (field) => field.name.toLowerCase() === NodeGraphDataFrameFieldNames.secondaryStat\n        );\n        if (field) {\n          field.config = { ...field.config, unit: options.nodes.secondaryStatUnit };\n        }\n      }\n      if (options?.nodes?.arcs?.length) {\n        for (const arc of options.nodes.arcs) {\n          // As the arc__ field suffixes can be custom we compare them case insensitively to be safe.\n          const field = frame.fields.find((field) => field.name.toLowerCase() === arc.field?.toLowerCase());\n          if (field && arc.color) {\n            field.config = { ...field.config, color: { fixedColor: arc.color, mode: FieldColorModeId.Fixed } };\n          }\n        }\n      }\n    }\n    return frame;\n  });\n};\n\n// Returns an array of node ids which are connected to a given edge\nexport const findConnectedNodesForEdge = (nodes: NodeDatum[], edges: EdgeDatum[], edgeId: string): string[] => {\n  const edge = edges.find((edge) => edge.id === edgeId);\n  if (edge) {\n    return [\n      ...new Set(nodes.filter((node) => edge.source === node.id || edge.target === node.id).map((node) => node.id)),\n    ];\n  }\n  return [];\n};\n\n// Returns an array of node ids which are connected to a given node\nexport const findConnectedNodesForNode = (nodes: NodeDatum[], edges: EdgeDatum[], nodeId: string): string[] => {\n  const node = nodes.find((node) => node.id === nodeId);\n  if (node) {\n    const linkedEdges = edges.filter((edge) => edge.source === node.id || edge.target === node.id);\n    return [\n      ...new Set(\n        linkedEdges.flatMap((edge) =>\n          nodes.filter((n) => edge.source === n.id || edge.target === n.id).map((n) => n.id)\n        )\n      ),\n    ];\n  }\n  return [];\n};\n\nexport const getGraphFrame = (frames: DataFrame[]) => {\n  return frames.reduce<GraphFrame>(\n    (acc, frame) => {\n      const sourceField = frame.fields.filter((f) => f.name === 'source');\n      if (frame.name === 'edges' || sourceField.length) {\n        acc.edges.push(frame);\n      } else {\n        acc.nodes.push(frame);\n      }\n      return acc;\n    },\n    { edges: [], nodes: [] }\n  );\n};\n","import { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { MouseEvent, memo } from 'react';\nimport tinycolor from 'tinycolor2';\n\nimport { Field, getFieldColorModeForField, GrafanaTheme2 } from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { Icon, useTheme2 } from '@grafana/ui';\n\nimport { HoverState } from './NodeGraph';\nimport { NodeDatum } from './types';\nimport { statToString } from './utils';\n\nexport const nodeR = 40;\nexport const highlightedNodeColor = '#a00';\n\nconst getStyles = (theme: GrafanaTheme2, hovering: HoverState) => ({\n  mainGroup: css({\n    cursor: 'pointer',\n    fontSize: '10px',\n    [theme.transitions.handleMotion('no-preference', 'reduce')]: {\n      transition: 'opacity 300ms',\n    },\n    opacity: hovering === 'inactive' ? 0.5 : 1,\n  }),\n\n  mainCircle: css({\n    fill: theme.components.panel.background,\n  }),\n\n  filledCircle: css({\n    fill: highlightedNodeColor,\n  }),\n\n  hoverCircle: css({\n    opacity: 0.5,\n    fill: 'transparent',\n    stroke: theme.colors.primary.text,\n  }),\n\n  text: css({\n    fill: theme.colors.text.primary,\n    pointerEvents: 'none',\n  }),\n\n  titleText: css({\n    textAlign: 'center',\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    whiteSpace: 'nowrap',\n    backgroundColor: tinycolor(theme.colors.background.primary).setAlpha(0.6).toHex8String(),\n    width: '140px',\n  }),\n\n  statsText: css({\n    textAlign: 'center',\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    whiteSpace: 'nowrap',\n    width: '70px',\n  }),\n\n  textHovering: css({\n    width: '200px',\n    '& span': {\n      backgroundColor: tinycolor(theme.colors.background.primary).setAlpha(0.8).toHex8String(),\n    },\n  }),\n\n  clickTarget: css({\n    fill: 'none',\n    stroke: 'none',\n    pointerEvents: 'fill',\n  }),\n});\n\nexport const computeNodeCircumferenceStrokeWidth = (nodeRadius: number) => Math.ceil(nodeRadius * 0.075);\n\nexport const Node = memo(function Node(props: {\n  node: NodeDatum;\n  hovering: HoverState;\n  onMouseEnter: (id: string) => void;\n  onMouseLeave: (id: string) => void;\n  onClick: (event: MouseEvent<SVGElement>, node: NodeDatum) => void;\n}) {\n  const { node, onMouseEnter, onMouseLeave, onClick, hovering } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme, hovering);\n  const isHovered = hovering === 'active';\n  const nodeRadius = node.nodeRadius?.values[node.dataFrameRowIndex] || nodeR;\n  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return (\n    <g\n      data-node-id={node.id}\n      className={styles.mainGroup}\n      aria-label={t('nodeGraph.node.aria-label-node-title', 'Node: {{nodeName}}', { nodeName: node.title })}\n    >\n      <circle\n        data-testid={`node-circle-${node.id}`}\n        className={node.highlighted ? styles.filledCircle : styles.mainCircle}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n      {isHovered && (\n        <circle className={styles.hoverCircle} r={nodeRadius - 3} cx={node.x} cy={node.y} strokeWidth={strokeWidth} />\n      )}\n      <ColorCircle node={node} />\n      <g className={styles.text} style={{ pointerEvents: 'none' }}>\n        <NodeContents node={node} hovering={hovering} />\n        <foreignObject\n          x={node.x - (isHovered ? 100 : 70)}\n          y={node.y + nodeRadius + 5}\n          width={isHovered ? '200' : '140'}\n          height=\"40\"\n        >\n          <div className={cx(styles.titleText, isHovered && styles.textHovering)}>\n            <span>{node.title}</span>\n            <br />\n            <span>{node.subTitle}</span>\n          </div>\n        </foreignObject>\n      </g>\n      <rect\n        data-testid={`node-click-rect-${node.id}`}\n        onMouseEnter={() => {\n          onMouseEnter(node.id);\n        }}\n        onMouseLeave={() => {\n          onMouseLeave(node.id);\n        }}\n        onClick={(event) => {\n          onClick(event, node);\n        }}\n        className={styles.clickTarget}\n        x={node.x - nodeRadius - 5}\n        y={node.y - nodeRadius - 5}\n        width={nodeRadius * 2 + 10}\n        height={nodeRadius * 2 + 50}\n      />\n    </g>\n  );\n});\n\n/**\n * Shows contents of the node which can be either an Icon or a main and secondary stat values.\n */\nfunction NodeContents({ node, hovering }: { node: NodeDatum; hovering: HoverState }) {\n  const theme = useTheme2();\n  const styles = getStyles(theme, hovering);\n  const isHovered = hovering === 'active';\n\n  if (!(node.x !== undefined && node.y !== undefined)) {\n    return null;\n  }\n\n  return node.icon ? (\n    <foreignObject x={node.x - 35} y={node.y - 20} width=\"70\" height=\"40\">\n      <div style={{ width: 70, overflow: 'hidden', display: 'flex', justifyContent: 'center', marginTop: -4 }}>\n        <Icon data-testid={`node-icon-${node.icon}`} name={node.icon} size={'xxxl'} />\n      </div>\n    </foreignObject>\n  ) : (\n    <foreignObject x={node.x - (isHovered ? 100 : 35)} y={node.y - 15} width={isHovered ? '200' : '70'} height=\"40\">\n      <div className={cx(styles.statsText, isHovered && styles.textHovering)}>\n        <span>{node.mainStat && statToString(node.mainStat.config, node.mainStat.values[node.dataFrameRowIndex])}</span>\n        <br />\n        <span>\n          {node.secondaryStat &&\n            statToString(node.secondaryStat.config, node.secondaryStat.values[node.dataFrameRowIndex])}\n        </span>\n      </div>\n    </foreignObject>\n  );\n}\n\n/**\n * Shows the outer segmented circle with different colors based on the supplied data.\n */\nfunction ColorCircle(props: { node: NodeDatum }) {\n  const { node } = props;\n  const fullStat = node.arcSections.find((s) => s.values[node.dataFrameRowIndex] >= 1);\n  const theme = useTheme2();\n  const nodeRadius = node.nodeRadius?.values[node.dataFrameRowIndex] || nodeR;\n  const strokeWidth = computeNodeCircumferenceStrokeWidth(nodeRadius);\n\n  if (fullStat) {\n    // Drawing a full circle with a `path` tag does not work well, it's better to use a `circle` tag in that case\n    return (\n      <circle\n        fill=\"none\"\n        stroke={theme.visualization.getColorByName(fullStat.config.color?.fixedColor || '')}\n        strokeWidth={strokeWidth}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n    );\n  }\n\n  const nonZero = node.arcSections.filter((s) => s.values[node.dataFrameRowIndex] !== 0);\n  if (nonZero.length === 0) {\n    // Fallback if no arc is defined\n    return (\n      <circle\n        fill=\"none\"\n        stroke={node.color ? getColor(node.color, node.dataFrameRowIndex, theme) : 'gray'}\n        strokeWidth={strokeWidth}\n        r={nodeRadius}\n        cx={node.x}\n        cy={node.y}\n      />\n    );\n  }\n\n  const { elements } = nonZero.reduce<{\n    elements: React.ReactNode[];\n    percent: number;\n  }>(\n    (acc, section, index) => {\n      const color = section.config.color?.fixedColor || '';\n      const value = section.values[node.dataFrameRowIndex];\n\n      const el = (\n        <ArcSection\n          key={index}\n          r={nodeRadius}\n          x={node.x!}\n          y={node.y!}\n          startPercent={acc.percent}\n          percent={\n            value + acc.percent > 1\n              ? // If the values aren't correct and add up to more than 100% lets still render correctly the amounts we\n                // already have and cap it at 100%\n                1 - acc.percent\n              : value\n          }\n          color={theme.visualization.getColorByName(color)}\n          strokeWidth={strokeWidth}\n        />\n      );\n      acc.elements.push(el);\n      acc.percent = acc.percent + value;\n      return acc;\n    },\n    { elements: [], percent: 0 }\n  );\n\n  return <>{elements}</>;\n}\n\nfunction ArcSection({\n  r,\n  x,\n  y,\n  startPercent,\n  percent,\n  color,\n  strokeWidth = 2,\n}: {\n  r: number;\n  x: number;\n  y: number;\n  startPercent: number;\n  percent: number;\n  color: string;\n  strokeWidth?: number;\n}) {\n  const endPercent = startPercent + percent;\n  const startXPos = x + Math.sin(2 * Math.PI * startPercent) * r;\n  const startYPos = y - Math.cos(2 * Math.PI * startPercent) * r;\n  const endXPos = x + Math.sin(2 * Math.PI * endPercent) * r;\n  const endYPos = y - Math.cos(2 * Math.PI * endPercent) * r;\n  const largeArc = percent > 0.5 ? '1' : '0';\n  return (\n    <path\n      fill=\"none\"\n      d={`M ${startXPos} ${startYPos} A ${r} ${r} 0 ${largeArc} 1 ${endXPos} ${endYPos}`}\n      stroke={color}\n      strokeWidth={strokeWidth}\n    />\n  );\n}\n\nfunction getColor(field: Field, index: number, theme: GrafanaTheme2): string {\n  if (!field.config.color) {\n    return field.values[index];\n  }\n\n  return getFieldColorModeForField(field).getCalculator(field, theme)(0, field.values[index]);\n}\n"],"names":["shortenLine","line","sourceNodeRadius","targetNodeRadius","arrowHeadHeight","vx","vy","mag","cosine","sine","scaledThickness","getNodeFields","nodes","normalizedFrames","field","fieldsCache","findFieldsByPrefix","getEdgeFields","edges","frame","prefix","f","processNodes","nodeFields","hasFixedPositions","v","nodesMap","i","id","makeNodeDatum","edgeDatums","processEdges","e","edgeFields","source","target","makeNodeDatumsFromEdge","computableField","normalizeStatsForNodes","index","sourceNode","targetNode","statToString","secondaryStatValues","mainStatValues","secondaryStatField","mainStatField","node","newNode","targetId","sourceId","makeSimpleNodeDatum","name","config","value","decimals","makeNodesDataFrame","count","partialNodes","nodesFrame","makeNode","partialNode","fields","key","makeEdgesDataFrame","edgesFrame","edge","graphBounds","bounds","acc","y","x","getNodeGraphDataFrames","frames","options","nodeGraphFrames","applyOptionsToFrames","arc","findConnectedNodesForEdge","edgeId","findConnectedNodesForNode","nodeId","linkedEdges","n","getGraphFrame","sourceField","nodeR","highlightedNodeColor","getStyles","theme","hovering","computeNodeCircumferenceStrokeWidth","nodeRadius","Node","props","onMouseEnter","onMouseLeave","onClick","styles","isHovered","strokeWidth","ColorCircle","NodeContents","event","fullStat","s","nonZero","getColor","elements","section","color","el","ArcSection","startPercent","percent","endPercent","startXPos","startYPos","endXPos","endYPos","largeArc"],"sourceRoot":""}