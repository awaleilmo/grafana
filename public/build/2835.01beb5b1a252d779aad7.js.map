{"version":3,"file":"2835.01beb5b1a252d779aad7.js","mappings":"iXAUO,SAASA,EAA4BC,EAAiB,CAC3D,MAAMC,KAAW,MAAY,EACvBC,KAAUC,EAAA,GACbC,GAAUA,EAAM,wBACnB,EAEA,sBAAU,IAAM,CACdH,KAAS,MAA8BD,CAAO,CAAC,CACjD,EAAG,CAACC,EAAUD,CAAO,CAAC,EAEfE,CACT,C,oCCYA,MAAMG,EAAe,CAAC,CAAE,QAAAL,CAAQ,IAAa,CAC3C,KAAM,CAACM,EAAYC,CAAa,KAAI,YAAiB,EAAE,EACjDC,KAAmB,eAAaC,GAAuC,CAC3EF,EAAcE,EAAM,cAAc,KAAK,CACzC,EAAG,CAAC,CAAC,EAEC,CAAE,QAAAC,EAAS,MAAAC,EAAO,OAAAC,EAAS,CAAC,CAAE,EAAIb,EAA4BC,CAAO,EAErEa,KAAS,MAAWC,CAAS,EAEnC,GAAIJ,GAAW,CAACC,EACd,SAAO,OAACI,EAAA,EAAkB,CAAC,QAAM,KAAE,8CAA+C,oBAAoB,EAAG,EAG3G,GAAIJ,GAAS,CAACD,EACZ,SACE,OAACM,EAAA,GACC,SAAO,KACL,mEACA,qCACF,EAEC,SAAAL,EAAM,QACT,EAIJ,MAAMM,EAA+D,CACnE,CACE,GAAI,QACJ,SAAO,KAAE,6CAA8C,OAAO,EAC9D,KAAM,cACN,WAAYC,CACd,EACA,CAAE,GAAI,QAAS,MAAO,GAAI,KAAM,OAAQ,WAAYC,CAAgB,EACpE,CACE,GAAI,YACJ,SAAO,KAAE,4CAA6C,MAAM,EAC5D,KAAM,cACN,WAAYC,CACd,CACF,EAGMC,EAAS,OAAO,QAAQC,EAAmBV,CAAM,CAAC,EAErD,KAAK,EACL,OAAO,CAAC,CAACW,CAAQ,IAAMC,EAASD,EAAUjB,CAAU,CAAC,EACrD,IAAI,CAAC,CAACiB,EAAUE,CAAK,IAAM,CAC1B,MAAMC,EAAgCD,EAAM,IAAKE,IAAiB,CAChE,GAAIA,EAAY,GAChB,KAAMA,CACR,EAAE,EAEF,SACE,QAAC,OACC,oBAAC,UAAO,UAAWd,EAAO,cACxB,mBAAC,QAAK,UAAWA,EAAO,YAAa,aAAYU,EAC9C,SAAAA,CAAA,CACH,EACF,KACA,OAACK,EAAA,EAAY,CAAC,KAAMX,EAAS,MAAOS,EAAY,WAAY,CAAE,aAAc,EAAG,EAAG,IAN1EH,CAOV,CAEJ,CAAC,EAEH,SACE,QAAC,OACC,oBAAC,OACC,mBAACM,EAAA,GACC,SACE,OAACC,EAAA,EAAK,CACJ,oBAACC,EAAA,EAAK,CAAC,IAAK,GAAK,WAAW,SAC1B,oBAAC,QACC,mBAAC,KAAK,CAAC,QAAQ,sCAAsC,wBAAY,EACnE,KACA,OAACC,EAAA,GACC,WACE,QAAC,OACC,oBAAC,KAAK,CAAC,QAAQ,8CAA8C,uGAE7D,KACA,QAAC,OACC,oBAAC,QAAM,4BAAmB,KAC1B,OAAC,QAAM,0BAAiB,GAC1B,GACF,EAGF,mBAACC,EAAA,EAAI,CAAC,KAAK,cAAc,KAAK,IAAK,GACrC,GACF,EACF,EAGF,mBAACC,EAAA,GACC,UAAQ,OAACD,EAAA,EAAI,CAAC,KAAM,SAAU,EAC9B,SAAUzB,EACV,eAAa,KAAE,4CAA6C,QAAQ,EACtE,EACF,EACF,EACCa,CAAA,EACH,CAEJ,EAGO,SAASC,EACdpB,EACiB,CACjB,MAAMuB,EAA+BvB,EAAQ,IAAKiC,GAAS,CAEzD,MAAMC,EAAe,SACfC,EAAoBF,EAAK,KAAK,MAAMC,CAAY,GAAG,GAAG,EAAE,GAAK,GAEnE,MAAO,CACL,GAAI,OAAOD,EAAK,EAAE,EAClB,MAAOA,EAAK,SAEZ,KAAMA,EAAK,KAAK,QAAQE,EAAmB,EAAE,EAC7C,KAAMF,EAAK,KACX,UAAWA,EAAK,QAChB,kBAAAE,CACF,CACF,CAAC,EAID,SAAO,WAAQZ,EAAQU,GAASA,EAAK,iBAAiB,CACxD,CAGO,SAASX,EAASD,EAAkBjB,EAAoB,CAE7D,GAAIA,IAAe,GACjB,MAAO,GAMT,GAAI,EAHaA,EAAW,WAAW,GAAG,GAAKA,EAAW,SAAS,GAAG,GAIpE,OAAOiB,EAAS,SAASjB,CAAU,EAKrC,GAAI,CACF,OAAO,IAAI,OAAOA,EAAW,MAAM,EAAG,EAAE,CAAC,EAAE,KAAKiB,CAAQ,CAC1D,MAAc,CACZ,MAAO,EACT,CACF,CAEA,SAASJ,EAAgBgB,EAAuB,CAC9C,MAAMG,EAAUH,EAAK,KAAK,MAAM,aAAe,CAAC,EAEhD,SACE,oBACG,UAAAA,EAAK,KAAK,QACX,OAACI,EAAA,CACE,SAAAD,EAAQ,IAAKE,MACZ,OAACC,EAAA,EAAU,CAAoB,SAAUD,EAAM,OAAQ,MAAO,OAAOA,EAAM,KAAK,GAA/DA,EAAM,MAA4D,CACpF,EACH,GACF,CAEJ,CAEA,SAAStB,EAAgBiB,EAAuB,CAC9C,SAAO,OAACO,EAAA,EAAa,CAAC,MAAOP,EAAK,KAAK,MAAO,CAChD,CAEA,SAASf,EAAoBe,EAAuB,CAClD,SACE,OAAC,OAAI,UAAWQ,EAAiB,SAAAR,EAAK,KAAK,cAAa,OAAC,QAAM,kBAAeA,EAAK,KAAK,SAAS,EAAE,EAAQ,CAE/G,CAEA,MAAMI,EAAgB,CAAC,CAAE,SAAAK,CAAS,IAAmC,CACnE,KAAM,CAAE,QAAAC,CAAQ,KAAI,MAAW/B,CAAS,EACxC,SAAO,OAAC,OAAI,UAAW+B,EAAU,SAAAD,CAAA,CAAS,CAC5C,EAEMD,KAAiB,OAAI,CACzB,QAAS,OACT,WAAY,WACZ,cAAe,QACjB,CAAC,EAEK7B,EAAagC,IAA0B,CAC3C,WAAS,OAAI,CACX,QAAS,CACP,YAAaA,EAAM,QAAQ,CAAC,CAC9B,CACF,CAAC,EACD,iBAAe,OAAI,CACjB,UAAWA,EAAM,QAAQ,CAAC,EAC1B,aAAcA,EAAM,QAAQ,CAAC,CAC/B,CAAC,EACD,eAAa,OAAI,CACf,UAAW,OACX,aAAc,WACd,WAAY,SACZ,QAAS,OACX,CAAC,CACH,GAEA,EAAezC,C,8FCrOR,MAAMoC,EAAa,CAAC,CAAE,SAAAM,EAAU,MAAAC,EAAO,SAAAC,EAAW,IAAK,cAAAC,CAAc,IAAa,CACvF,MAAMrC,KAAS,MAAWC,CAAS,EAEnC,SACE,QAAC,OAAI,UAAWD,EAAO,QACpB,UAAAkC,EACAE,EACAD,EACA,CAAC,CAACE,MACD,OAAC,KACC,KAAK,QACL,KAAK,KACL,QAASA,EACT,WAAS,KAAE,4CAA6C,cAAc,EACxE,GAEJ,CAEJ,EAEapC,EAAagC,IAA0B,CAClD,WAAS,OAAI,CACX,QAASA,EAAM,QAAQ,GAAK,CAAC,EAC7B,aAAcA,EAAM,MAAM,OAAO,QACjC,OAAQ,aAAaA,EAAM,OAAO,OAAO,MAAM,GAC/C,SAAUA,EAAM,WAAW,UAAU,SACrC,gBAAiBA,EAAM,OAAO,WAAW,UACzC,WAAYA,EAAM,WAAW,eAC7B,MAAOA,EAAM,OAAO,KAAK,QACzB,QAAS,eACT,WAAY,KACd,CAAC,CACH,E","sources":["webpack://grafana/./public/app/features/alerting/unified/hooks/useManagedAlertStateHistory.ts","webpack://grafana/./public/app/features/alerting/unified/components/rules/state-history/StateHistory.tsx","webpack://grafana/./public/app/features/alerting/unified/components/AlertLabel.tsx"],"sourcesContent":["import { useEffect } from 'react';\n\nimport { useDispatch } from 'app/types/store';\nimport { StateHistoryItem } from 'app/types/unified-alerting';\n\nimport { fetchGrafanaAnnotationsAction } from '../state/actions';\nimport { AsyncRequestState } from '../utils/redux';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\nexport function useManagedAlertStateHistory(ruleUID: string) {\n  const dispatch = useDispatch();\n  const history = useUnifiedAlertingSelector<AsyncRequestState<StateHistoryItem[]>>(\n    (state) => state.managedAlertStateHistory\n  );\n\n  useEffect(() => {\n    dispatch(fetchGrafanaAnnotationsAction(ruleUID));\n  }, [dispatch, ruleUID]);\n\n  return history;\n}\n","import { css } from '@emotion/css';\nimport { groupBy } from 'lodash';\nimport { FormEvent, useCallback, useState } from 'react';\nimport * as React from 'react';\n\nimport { AlertState, GrafanaTheme2, dateTimeFormat } from '@grafana/data';\nimport { Trans, t } from '@grafana/i18n';\nimport { Alert, Field, Icon, Input, Label, LoadingPlaceholder, Stack, Tooltip, useStyles2 } from '@grafana/ui';\nimport { StateHistoryItem, StateHistoryItemData } from 'app/types/unified-alerting';\nimport { GrafanaAlertStateWithReason, PromAlertingRuleState } from 'app/types/unified-alerting-dto';\n\nimport { useManagedAlertStateHistory } from '../../../hooks/useManagedAlertStateHistory';\nimport { AlertLabel } from '../../AlertLabel';\nimport { DynamicTable, DynamicTableColumnProps, DynamicTableItemProps } from '../../DynamicTable';\nimport { AlertStateTag } from '../AlertStateTag';\n\ntype StateHistoryRowItem = {\n  id: string;\n  state: PromAlertingRuleState | GrafanaAlertStateWithReason | AlertState;\n  text?: string;\n  data?: StateHistoryItemData;\n  timestamp?: number;\n  stringifiedLabels: string;\n};\n\ntype StateHistoryMap = Record<string, StateHistoryRowItem[]>;\n\ntype StateHistoryRow = DynamicTableItemProps<StateHistoryRowItem>;\n\ninterface Props {\n  ruleUID: string;\n}\n\nconst StateHistory = ({ ruleUID }: Props) => {\n  const [textFilter, setTextFilter] = useState<string>('');\n  const handleTextFilter = useCallback((event: FormEvent<HTMLInputElement>) => {\n    setTextFilter(event.currentTarget.value);\n  }, []);\n\n  const { loading, error, result = [] } = useManagedAlertStateHistory(ruleUID);\n\n  const styles = useStyles2(getStyles);\n\n  if (loading && !error) {\n    return <LoadingPlaceholder text={t('alerting.state-history.text-loading-history', 'Loading history...')} />;\n  }\n\n  if (error && !loading) {\n    return (\n      <Alert\n        title={t(\n          'alerting.state-history.title-failed-to-fetch-alert-state-history',\n          'Failed to fetch alert state history'\n        )}\n      >\n        {error.message}\n      </Alert>\n    );\n  }\n\n  const columns: Array<DynamicTableColumnProps<StateHistoryRowItem>> = [\n    {\n      id: 'state',\n      label: t('alerting.state-history.columns.label.state', 'State'),\n      size: 'max-content',\n      renderCell: renderStateCell,\n    },\n    { id: 'value', label: '', size: 'auto', renderCell: renderValueCell },\n    {\n      id: 'timestamp',\n      label: t('alerting.state-history.columns.label.time', 'Time'),\n      size: 'max-content',\n      renderCell: renderTimestampCell,\n    },\n  ];\n\n  // group the state history list by unique set of labels\n  const tables = Object.entries(groupStateByLabels(result))\n    // sort and filter each table\n    .sort()\n    .filter(([groupKey]) => matchKey(groupKey, textFilter))\n    .map(([groupKey, items]) => {\n      const tableItems: StateHistoryRow[] = items.map((historyItem) => ({\n        id: historyItem.id,\n        data: historyItem,\n      }));\n\n      return (\n        <div key={groupKey}>\n          <header className={styles.tableGroupKey}>\n            <code className={styles.goupKeyText} aria-label={groupKey}>\n              {groupKey}\n            </code>\n          </header>\n          <DynamicTable cols={columns} items={tableItems} pagination={{ itemsPerPage: 25 }} />\n        </div>\n      );\n    });\n\n  return (\n    <div>\n      <nav>\n        <Field\n          label={\n            <Label>\n              <Stack gap={0.5} alignItems=\"center\">\n                <span>\n                  <Trans i18nKey=\"alerting.state-history.filter-group\">Filter group</Trans>\n                </span>\n                <Tooltip\n                  content={\n                    <div>\n                      <Trans i18nKey=\"alerting.state-history.filter-group-tooltip\">\n                        Filter each state history group either by exact match or a regular expression, for example:\n                      </Trans>\n                      <div>\n                        <code>{`region=eu-west-1`}</code>\n                        <code>{`/region=us-.+/`}</code>\n                      </div>\n                    </div>\n                  }\n                >\n                  <Icon name=\"info-circle\" size=\"sm\" />\n                </Tooltip>\n              </Stack>\n            </Label>\n          }\n        >\n          <Input\n            prefix={<Icon name={'search'} />}\n            onChange={handleTextFilter}\n            placeholder={t('alerting.state-history.placeholder-search', 'Search')}\n          />\n        </Field>\n      </nav>\n      {tables}\n    </div>\n  );\n};\n\n// group state history by labels\nexport function groupStateByLabels(\n  history: Array<Pick<StateHistoryItem, 'id' | 'newState' | 'text' | 'data' | 'updated'>>\n): StateHistoryMap {\n  const items: StateHistoryRowItem[] = history.map((item) => {\n    // let's grab the last matching set of `{<string>}` since the alert name could also contain { or }\n    const LABELS_REGEX = /{.*?}/g;\n    const stringifiedLabels = item.text.match(LABELS_REGEX)?.at(-1) ?? '';\n\n    return {\n      id: String(item.id),\n      state: item.newState,\n      // let's omit the labels for each entry since it's just added noise to each state history item\n      text: item.text.replace(stringifiedLabels, ''),\n      data: item.data,\n      timestamp: item.updated,\n      stringifiedLabels,\n    };\n  });\n\n  // we have to group our state history items by their unique combination of tags since we want to display a DynamicTable for each alert instance\n  // (effectively unique combination of labels)\n  return groupBy(items, (item) => item.stringifiedLabels);\n}\n\n// match a string either by exact text match or with regular expression when in the form of \"/<regex>/\"\nexport function matchKey(groupKey: string, textFilter: string) {\n  // if the text filter is empty we show all matches\n  if (textFilter === '') {\n    return true;\n  }\n\n  const isRegExp = textFilter.startsWith('/') && textFilter.endsWith('/');\n\n  // not a regular expression, use normal text matching\n  if (!isRegExp) {\n    return groupKey.includes(textFilter);\n  }\n\n  // regular expression, try parsing and applying\n  // when we fail to parse the text as a regular expression, we return no match\n  try {\n    return new RegExp(textFilter.slice(1, -1)).test(groupKey);\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction renderValueCell(item: StateHistoryRow) {\n  const matches = item.data.data?.evalMatches ?? [];\n\n  return (\n    <>\n      {item.data.text}\n      <LabelsWrapper>\n        {matches.map((match) => (\n          <AlertLabel key={match.metric} labelKey={match.metric} value={String(match.value)} />\n        ))}\n      </LabelsWrapper>\n    </>\n  );\n}\n\nfunction renderStateCell(item: StateHistoryRow) {\n  return <AlertStateTag state={item.data.state} />;\n}\n\nfunction renderTimestampCell(item: StateHistoryRow) {\n  return (\n    <div className={TimestampStyle}>{item.data.timestamp && <span>{dateTimeFormat(item.data.timestamp)}</span>}</div>\n  );\n}\n\nconst LabelsWrapper = ({ children }: React.PropsWithChildren<{}>) => {\n  const { wrapper } = useStyles2(getStyles);\n  return <div className={wrapper}>{children}</div>;\n};\n\nconst TimestampStyle = css({\n  display: 'flex',\n  alignItems: 'flex-end',\n  flexDirection: 'column',\n});\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    '& > *': {\n      marginRight: theme.spacing(1),\n    },\n  }),\n  tableGroupKey: css({\n    marginTop: theme.spacing(2),\n    marginBottom: theme.spacing(2),\n  }),\n  goupKeyText: css({\n    overflowX: 'auto',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    display: 'block',\n  }),\n});\n\nexport default StateHistory;\n","import { css } from '@emotion/css';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { IconButton, useStyles2 } from '@grafana/ui';\n\ninterface Props {\n  labelKey: string;\n  value: string;\n  operator?: string;\n  onRemoveLabel?: () => void;\n}\n\nexport const AlertLabel = ({ labelKey, value, operator = '=', onRemoveLabel }: Props) => {\n  const styles = useStyles2(getStyles);\n\n  return (\n    <div className={styles.wrapper}>\n      {labelKey}\n      {operator}\n      {value}\n      {!!onRemoveLabel && (\n        <IconButton\n          name=\"times\"\n          size=\"xs\"\n          onClick={onRemoveLabel}\n          tooltip={t('alerting.alert-label.tooltip-remove-label', 'Remove label')}\n        />\n      )}\n    </div>\n  );\n};\n\nexport const getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    padding: theme.spacing(0.5, 1),\n    borderRadius: theme.shape.radius.default,\n    border: `solid 1px ${theme.colors.border.medium}`,\n    fontSize: theme.typography.bodySmall.fontSize,\n    backgroundColor: theme.colors.background.secondary,\n    fontWeight: theme.typography.fontWeightBold,\n    color: theme.colors.text.primary,\n    display: 'inline-block',\n    lineHeight: '1.2',\n  }),\n});\n"],"names":["useManagedAlertStateHistory","ruleUID","dispatch","history","useUnifiedAlertingSelector","state","StateHistory","textFilter","setTextFilter","handleTextFilter","event","loading","error","result","styles","getStyles","LoadingPlaceholder","Alert","columns","renderStateCell","renderValueCell","renderTimestampCell","tables","groupStateByLabels","groupKey","matchKey","items","tableItems","historyItem","DynamicTable","Field","Label","Stack","Tooltip","Icon","Input","item","LABELS_REGEX","stringifiedLabels","matches","LabelsWrapper","match","AlertLabel","AlertStateTag","TimestampStyle","children","wrapper","theme","labelKey","value","operator","onRemoveLabel"],"sourceRoot":""}