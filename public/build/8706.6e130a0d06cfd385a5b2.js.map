{"version":3,"file":"8706.6e130a0d06cfd385a5b2.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/panel/barchart/distribute.ts","webpack://grafana/./public/app/core/components/TimelineChart/timeline.ts","webpack://grafana/./public/app/core/components/TimelineChart/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/quadtree.ts"],"sourcesContent":["import { roundDecimals } from '@grafana/data';\n\nexport const SPACE_BETWEEN = 1;\nexport const SPACE_AROUND = 2;\nexport const SPACE_EVENLY = 3;\n\nconst coord = (i: number, offs: number, iwid: number, gap: number) => roundDecimals(offs + i * (iwid + gap), 6);\n\nexport type Each = (idx: number, offPct: number, dimPct: number) => void;\n\n/**\n * @internal\n */\nexport function distribute(numItems: number, sizeFactor: number, justify: number, onlyIdx: number | null, each: Each) {\n  let space = 1 - sizeFactor;\n\n  /* eslint-disable no-multi-spaces */\n  // prettier-ignore\n  let gap = (\n    justify === SPACE_BETWEEN ? space / (numItems - 1) :\n    justify === SPACE_AROUND  ? space / (numItems  )   :\n    justify === SPACE_EVENLY  ? space / (numItems + 1) : 0\n  );\n\n  if (isNaN(gap) || gap === Infinity) {\n    gap = 0;\n  }\n\n  // prettier-ignore\n  let offs = (\n    justify === SPACE_BETWEEN ? 0       :\n    justify === SPACE_AROUND  ? gap / 2 :\n    justify === SPACE_EVENLY  ? gap     : 0\n  );\n  /* eslint-enable */\n\n  let iwid = sizeFactor / numItems;\n  let _iwid = roundDecimals(iwid, 6);\n\n  if (onlyIdx == null) {\n    for (let i = 0; i < numItems; i++) {\n      each(i, coord(i, offs, iwid, gap), _iwid);\n    }\n  } else {\n    each(onlyIdx, coord(onlyIdx, offs, iwid, gap), _iwid);\n  }\n}\n","import uPlot, { Series } from 'uplot';\n\nimport { GrafanaTheme2, TimeRange, colorManipulator } from '@grafana/data';\nimport { TimelineValueAlignment, VisibilityMode } from '@grafana/schema';\nimport { FIXED_UNIT } from '@grafana/ui';\nimport { distribute, SPACE_BETWEEN } from 'app/plugins/panel/barchart/distribute';\nimport { Quadtree, Rect } from 'app/plugins/panel/barchart/quadtree';\nimport { FieldConfig as StateTimeLineFieldConfig } from 'app/plugins/panel/state-timeline/panelcfg.gen';\nimport { FieldConfig as StatusHistoryFieldConfig } from 'app/plugins/panel/status-history/panelcfg.gen';\n\nimport { TimelineMode } from './utils';\n\nconst { round, min, ceil } = Math;\n\nconst textPadding = 2;\n\nlet pxPerChar = 6;\n\nconst laneDistr = SPACE_BETWEEN;\n\ntype WalkCb = (idx: number, offPx: number, dimPx: number) => void;\n\nfunction walk(rowHeight: number, yIdx: number | null, count: number, dim: number, draw: WalkCb) {\n  distribute(count, rowHeight, laneDistr, yIdx, (i, offPct, dimPct) => {\n    let laneOffPx = dim * offPct;\n    let laneWidPx = dim * dimPct;\n\n    draw(i, laneOffPx, laneWidPx);\n  });\n}\n\ninterface TimelineBoxRect extends Rect {\n  fillColor: string;\n}\n\n/**\n * @internal\n */\nexport interface TimelineCoreOptions {\n  mode: TimelineMode;\n  alignValue?: TimelineValueAlignment;\n  numSeries: number;\n  rowHeight?: number;\n  colWidth?: number;\n  theme: GrafanaTheme2;\n  showValue: VisibilityMode;\n  mergeValues?: boolean;\n  isDiscrete: (seriesIdx: number) => boolean;\n  hasMappedNull: (seriesIdx: number) => boolean;\n  hasMappedNaN: (seriesIdx: number) => boolean;\n  getValueColor: (seriesIdx: number, value: unknown) => string;\n  label: (seriesIdx: number) => string;\n  getTimeRange: () => TimeRange;\n  formatValue?: (seriesIdx: number, value: unknown) => string;\n  getFieldConfig: (seriesIdx: number) => StateTimeLineFieldConfig | StatusHistoryFieldConfig;\n  hoverMulti: boolean;\n}\n\n/**\n * @internal\n */\nexport function shouldDrawYValue(yValue: unknown, mappedNull?: boolean, mappedNaN?: boolean): boolean {\n  if (typeof yValue === 'boolean') {\n    return true;\n  }\n  if (typeof yValue === 'string') {\n    return true;\n  }\n  if (typeof yValue === 'number' && !Number.isNaN(yValue)) {\n    return true;\n  }\n  if (yValue === null && mappedNull) {\n    return true;\n  }\n  if (Number.isNaN(yValue) && mappedNaN) {\n    return true;\n  }\n  return !!yValue;\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: TimelineCoreOptions) {\n  const {\n    mode,\n    numSeries,\n    isDiscrete,\n    hasMappedNull,\n    hasMappedNaN,\n    rowHeight = 0,\n    colWidth = 0,\n    showValue,\n    mergeValues = false,\n    theme,\n    label,\n    formatValue,\n    alignValue = 'left',\n    getTimeRange,\n    getValueColor,\n    getFieldConfig,\n    hoverMulti,\n  } = opts;\n\n  let qt: Quadtree;\n\n  // Needed for to calculate text positions\n  let boxRectsBySeries: TimelineBoxRect[][];\n\n  const resetBoxRectsBySeries = (count: number) => {\n    boxRectsBySeries = Array(numSeries)\n      .fill(null)\n      .map((v) => Array(count).fill(null));\n  };\n\n  const font = `500 ${Math.round(12 * devicePixelRatio)}px ${theme.typography.fontFamily}`;\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n  let hoveredAtCursor: Rect | null = null;\n\n  const size = [colWidth, Infinity];\n  const gapFactor = 1 - size[0];\n  const maxWidth = (size[1] ?? Infinity) * uPlot.pxRatio;\n\n  const fillPaths: Map<CanvasRenderingContext2D['fillStyle'], Path2D> = new Map();\n  const strokePaths: Map<CanvasRenderingContext2D['strokeStyle'], Path2D> = new Map();\n\n  function drawBoxes(ctx: CanvasRenderingContext2D) {\n    fillPaths.forEach((fillPath, fillStyle) => {\n      ctx.fillStyle = fillStyle;\n      ctx.fill(fillPath);\n    });\n\n    strokePaths.forEach((strokePath, strokeStyle) => {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke(strokePath);\n    });\n\n    fillPaths.clear();\n    strokePaths.clear();\n  }\n\n  function putBox(\n    ctx: CanvasRenderingContext2D,\n    rect: uPlot.RectH,\n    xOff: number,\n    yOff: number,\n    left: number,\n    top: number,\n    boxWidth: number,\n    boxHeight: number,\n    strokeWidth: number,\n    seriesIdx: number,\n    valueIdx: number,\n    value: number | null,\n    discrete: boolean\n  ) {\n    // clamp width to allow small boxes to be rendered\n    boxWidth = Math.max(1, boxWidth);\n\n    const valueColor = getValueColor(seriesIdx + 1, value);\n    const fieldConfig = getFieldConfig(seriesIdx);\n    const fillColor = getFillColor(fieldConfig, valueColor);\n\n    boxRectsBySeries[seriesIdx][valueIdx] = {\n      x: round(left - xOff),\n      y: round(top - yOff),\n      w: boxWidth,\n      h: boxHeight,\n      sidx: seriesIdx + 1,\n      didx: valueIdx,\n      // for computing label contrast\n      fillColor,\n    };\n\n    if (discrete) {\n      let fillStyle = fillColor;\n      let fillPath = fillPaths.get(fillStyle);\n\n      if (fillPath == null) {\n        fillPaths.set(fillStyle, (fillPath = new Path2D()));\n      }\n\n      rect(fillPath, left, top, boxWidth, boxHeight);\n\n      if (strokeWidth) {\n        let strokeStyle = valueColor;\n        let strokePath = strokePaths.get(strokeStyle);\n\n        if (strokePath == null) {\n          strokePaths.set(strokeStyle, (strokePath = new Path2D()));\n        }\n\n        rect(\n          strokePath,\n          left + strokeWidth / 2,\n          top + strokeWidth / 2,\n          boxWidth - strokeWidth,\n          boxHeight - strokeWidth\n        );\n      }\n    } else {\n      ctx.beginPath();\n      rect(ctx, left, top, boxWidth, boxHeight);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      if (strokeWidth) {\n        ctx.beginPath();\n        rect(ctx, left + strokeWidth / 2, top + strokeWidth / 2, boxWidth - strokeWidth, boxHeight - strokeWidth);\n        ctx.strokeStyle = valueColor;\n        ctx.lineWidth = strokeWidth;\n        ctx.stroke();\n      }\n    }\n  }\n\n  const drawPaths: Series.PathBuilder = (u, sidx, idx0, idx1) => {\n    uPlot.orient(\n      u,\n      sidx,\n      (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect) => {\n        let strokeWidth = round((series.width || 0) * uPlot.pxRatio);\n        const discrete = isDiscrete(sidx);\n        const mappedNull = discrete && hasMappedNull(sidx);\n        const mappedNaN = discrete && hasMappedNaN(sidx);\n\n        u.ctx.save();\n        rect(u.ctx, u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n\n        walk(rowHeight, sidx - 1, numSeries, yDim, (iy, y0, height) => {\n          if (mode === TimelineMode.Changes) {\n            for (let ix = 0; ix < dataY.length; ix++) {\n              let yVal = dataY[ix];\n              const shouldDrawY = shouldDrawYValue(yVal, mappedNull, mappedNaN);\n\n              if (shouldDrawY) {\n                let left = Math.round(valToPosX(dataX[ix], scaleX, xDim, xOff));\n\n                let nextIx = ix;\n                while (\n                  ++nextIx < dataY.length &&\n                  (dataY[nextIx] === undefined || (mergeValues && dataY[nextIx] === yVal))\n                ) {}\n\n                // to now (not to end of chart)\n                let right =\n                  nextIx === dataY.length\n                    ? xOff + xDim + strokeWidth\n                    : Math.round(valToPosX(dataX[nextIx], scaleX, xDim, xOff));\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  left,\n                  round(yOff + y0),\n                  right - left,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n\n                ix = nextIx - 1;\n              }\n            }\n          } else if (mode === TimelineMode.Samples) {\n            let colWid = valToPosX(dataX[1], scaleX, xDim, xOff) - valToPosX(dataX[0], scaleX, xDim, xOff);\n            let gapWid = colWid * gapFactor;\n            let barWid = round(min(maxWidth, colWid - gapWid) - strokeWidth);\n            let xShift = barWid / 2;\n            //let xShift = align === 1 ? 0 : align === -1 ? barWid : barWid / 2;\n\n            for (let ix = idx0; ix <= idx1; ix++) {\n              let yVal = dataY[ix];\n              const shouldDrawY = shouldDrawYValue(yVal, mappedNull, mappedNaN);\n\n              if (shouldDrawY) {\n                // TODO: all xPos can be pre-computed once for all series in aligned set\n                let left = valToPosX(dataX[ix], scaleX, xDim, xOff);\n\n                putBox(\n                  u.ctx,\n                  rect,\n                  xOff,\n                  yOff,\n                  round(left - xShift),\n                  round(yOff + y0),\n                  barWid,\n                  round(height),\n                  strokeWidth,\n                  iy,\n                  ix,\n                  yVal,\n                  discrete\n                );\n              }\n            }\n          }\n        });\n\n        if (discrete) {\n          u.ctx.lineWidth = strokeWidth;\n          drawBoxes(u.ctx);\n        }\n\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n\n  const drawPoints: Series.Points.Show =\n    formatValue == null || showValue === VisibilityMode.Never\n      ? false\n      : (u, sidx, i0, i1) => {\n          u.ctx.save();\n          u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n          u.ctx.clip();\n\n          u.ctx.font = font;\n          u.ctx.textAlign = mode === TimelineMode.Changes ? alignValue : 'center';\n          u.ctx.textBaseline = 'middle';\n\n          uPlot.orient(\n            u,\n            sidx,\n            (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n              let strokeWidth = round((series.width || 0) * uPlot.pxRatio);\n              let y = round(valToPosY(ySplits[sidx - 1], scaleY, yDim, yOff));\n\n              const discrete = isDiscrete(sidx);\n              const mappedNull = discrete && hasMappedNull(sidx);\n              const mappedNaN = discrete && hasMappedNaN(sidx);\n\n              for (let ix = 0; ix < dataY.length; ix++) {\n                const yVal = dataY[ix];\n                const shouldDrawY = shouldDrawYValue(yVal, mappedNull, mappedNaN);\n\n                if (shouldDrawY) {\n                  const boxRect = boxRectsBySeries[sidx - 1][ix];\n\n                  if (!boxRect || boxRect.x >= xDim) {\n                    continue;\n                  }\n\n                  // if x placement is negative, rect is left truncated, remove it from width for calculating how many chars will display\n                  // right truncation happens automatically\n                  const displayedBoxWidth = boxRect.x < 0 ? boxRect?.w + boxRect.x : boxRect?.w;\n\n                  let maxChars = Math.floor(displayedBoxWidth / pxPerChar);\n\n                  if (showValue === VisibilityMode.Auto && maxChars < 2) {\n                    continue;\n                  }\n\n                  let txt = formatValue(sidx, dataY[ix]);\n\n                  // center-aligned\n                  let x = round(boxRect.x + xOff + boxRect.w / 2);\n                  if (mode === TimelineMode.Changes) {\n                    if (alignValue === 'left') {\n                      x = round(Math.max(boxRect.x, 0) + xOff + strokeWidth + textPadding);\n                    } else if (alignValue === 'right') {\n                      x = round(boxRect.x + xOff + boxRect.w - strokeWidth - textPadding);\n                    }\n                  }\n\n                  // TODO: cache by fillColor to avoid setting ctx for label\n                  u.ctx.fillStyle = theme.colors.getContrastText(boxRect.fillColor, 3);\n                  u.ctx.fillText(txt.slice(0, maxChars), x, y);\n                }\n              }\n            }\n          );\n\n          u.ctx.restore();\n\n          return false;\n        };\n\n  const init = (u: uPlot) => {\n    let chars = '';\n    for (let i = 32; i <= 126; i++) {\n      chars += String.fromCharCode(i);\n    }\n    pxPerChar = Math.ceil((u.ctx.measureText(chars).width / chars.length) * uPlot.pxRatio);\n\n    // be a bit more conservtive to prevent overlap\n    pxPerChar += 2.5;\n\n    u.root.querySelectorAll<HTMLDivElement>('.u-cursor-pt').forEach((el) => {\n      el.style.borderRadius = '0';\n    });\n  };\n\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n    resetBoxRectsBySeries(u.data[0].length);\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n  };\n\n  function setHovered(cx: number, cy: number, viaSync = false) {\n    hovered.fill(null);\n    hoveredAtCursor = null;\n\n    if (cx < 0) {\n      return;\n    }\n\n    // first gets all items in all quads intersected by a 1px wide by 10k high rect at the x cursor position and 0 y position.\n    // (we use 10k instead of plot area height for simplicity and not having to pass around the uPlot instance)\n    qt.get(cx, 0, uPlot.pxRatio, 1e4, (o) => {\n      // filter only rects that intersect along x dir\n      if (cx >= o.x && cx <= o.x + o.w) {\n        // if also intersect along y dir, set both \"direct hovered\" and \"one-of hovered\"\n        if (cy >= o.y && cy <= o.y + o.h) {\n          hovered[o.sidx] = hoveredAtCursor = o;\n        }\n        // else only set \"one-of hovered\" (no \"direct hovered\") in multi mode or when synced\n        else if (hoverMulti || viaSync) {\n          hovered[o.sidx] = o;\n        }\n      }\n    });\n  }\n\n  const cursor: uPlot.Cursor = {\n    x: mode === TimelineMode.Changes,\n    y: false,\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        // if quadtree is empty, fill it\n        if (qt.o.length === 0 && qt.q == null) {\n          for (const seriesRects of boxRectsBySeries) {\n            for (const rect of seriesRects) {\n              rect && qt.add(rect);\n            }\n          }\n        }\n\n        let cx = u.cursor.left! * uPlot.pxRatio;\n        let cy = u.cursor.top! * uPlot.pxRatio;\n\n        setHovered(cx, cy, u.cursor.event == null);\n      }\n\n      return hovered[seriesIdx]?.didx;\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hoveredAtCursor?.sidx === seriesIdx ? 0 : Infinity),\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.2)',\n      bbox: (u, seriesIdx) => {\n        let hRect = hovered[seriesIdx];\n        let isHovered = hRect != null;\n\n        return {\n          left: isHovered ? hRect!.x / uPlot.pxRatio : -10,\n          top: isHovered ? hRect!.y / uPlot.pxRatio : -10,\n          width: isHovered ? hRect!.w / uPlot.pxRatio : 0,\n          height: isHovered ? hRect!.h / uPlot.pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  const ySplits: number[] = Array(numSeries).fill(0);\n  const yRange: uPlot.Range.MinMax = [0, 1];\n\n  return {\n    cursor,\n\n    xSplits:\n      mode === TimelineMode.Samples\n        ? (u: uPlot, axisIdx: number, scaleMin: number, scaleMax: number, foundIncr: number, foundSpace: number) => {\n            let splits = [];\n\n            let dataIncr = u.data[0][1] - u.data[0][0];\n            let skipFactor = ceil(foundIncr / dataIncr);\n\n            for (let i = 0; i < u.data[0].length; i += skipFactor) {\n              let v = u.data[0][i];\n\n              if (v >= scaleMin && v <= scaleMax) {\n                splits.push(v);\n              }\n            }\n\n            return splits;\n          }\n        : null,\n\n    xRange: (u: uPlot) => {\n      const r = getTimeRange();\n\n      let min = r.from.valueOf();\n      let max = r.to.valueOf();\n\n      if (mode === TimelineMode.Samples) {\n        let colWid = u.data[0][1] - u.data[0][0];\n        let scalePad = colWid / 2;\n\n        if (min <= u.data[0][0]) {\n          min = u.data[0][0] - scalePad;\n        }\n\n        let lastIdx = u.data[0].length - 1;\n\n        if (max >= u.data[0][lastIdx]) {\n          max = u.data[0][lastIdx] + scalePad;\n        }\n      }\n\n      const result: uPlot.Range.MinMax = [min, max];\n      return result;\n    },\n\n    ySplits: (u: uPlot) => {\n      walk(rowHeight, null, numSeries, u.bbox.height, (iy, y0, hgt) => {\n        // vertical midpoints of each series' timeline (stored relative to .u-over)\n        let yMid = round(y0 + hgt / 2);\n        ySplits[iy] = u.posToVal(yMid / uPlot.pxRatio, FIXED_UNIT);\n      });\n\n      return ySplits;\n    },\n\n    yValues: (u: uPlot, splits: number[]) => splits.map((v, i) => label(i + 1)),\n    yRange,\n\n    // pathbuilders\n    drawPaths,\n    drawPoints,\n\n    // hooks\n    init,\n    drawClear,\n  };\n}\n\nfunction getFillColor(fieldConfig: { fillOpacity?: number; lineWidth?: number }, color: string) {\n  // if #rgba with pre-existing alpha. ignore fieldConfig.fillOpacity\n  // e.g. thresholds with opacity\n  if (color[0] === '#' && color.length === 9) {\n    return color;\n  }\n\n  const opacityPercent = (fieldConfig.fillOpacity ?? 100) / 100;\n  return colorManipulator.alpha(color, opacityPercent);\n}\n","import {\n  DataFrame,\n  FALLBACK_COLOR,\n  Field,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldDisplayName,\n  getValueFormat,\n  GrafanaTheme2,\n  getActiveThreshold,\n  Threshold,\n  getFieldConfigWithMinMax,\n  ThresholdsMode,\n  TimeRange,\n  cacheFieldDisplayNames,\n  outerJoinDataFrames,\n  ValueMapping,\n  ThresholdsConfig,\n  applyNullInsertThreshold,\n  nullToValue,\n  SpecialValueMatch,\n} from '@grafana/data';\nimport { maybeSortFrame, NULL_RETAIN } from '@grafana/data/internal';\nimport { t } from '@grafana/i18n';\nimport {\n  VizLegendOptions,\n  AxisPlacement,\n  ScaleDirection,\n  ScaleOrientation,\n  VisibilityMode,\n  TimelineValueAlignment,\n  HideableFieldConfig,\n  MappingType,\n} from '@grafana/schema';\nimport { FIXED_UNIT, UPlotConfigBuilder, UPlotConfigPrepFn, VizLegendItem } from '@grafana/ui';\nimport { preparePlotData2, getStackingGroups } from '@grafana/ui/internal';\n\nimport { getConfig, TimelineCoreOptions } from './timeline';\n\n/**\n * @internal\n */\ninterface UPlotConfigOptions {\n  frame: DataFrame;\n  theme: GrafanaTheme2;\n  mode: TimelineMode;\n  rowHeight?: number;\n  colWidth?: number;\n  showValue: VisibilityMode;\n  alignValue?: TimelineValueAlignment;\n  mergeValues?: boolean;\n  getValueColor: (frameIdx: number, fieldIdx: number, value: unknown) => string;\n  hoverMulti: boolean;\n  axisWidth?: number;\n}\n\n/**\n * @internal\n */\ninterface PanelFieldConfig extends HideableFieldConfig {\n  fillOpacity?: number;\n  lineWidth?: number;\n}\n\nexport enum TimelineMode {\n  Changes = 'changes',\n  Samples = 'samples',\n}\n\nconst defaultConfig: PanelFieldConfig = {\n  lineWidth: 0,\n  fillOpacity: 80,\n};\n\n/** Checks if a mapped value of the specified type exists for the given field */\nexport const hasSpecialMappedValue = (field: Field, match: SpecialValueMatch): boolean =>\n  field.config.mappings?.some(\n    (mapping: ValueMapping): boolean => mapping.type === MappingType.SpecialValue && mapping.options.match === match\n  ) || false;\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn<UPlotConfigOptions> = ({\n  frame,\n  theme,\n  timeZones,\n  getTimeRange,\n  mode,\n  rowHeight,\n  colWidth,\n  showValue,\n  alignValue,\n  mergeValues,\n  getValueColor,\n  hoverMulti,\n}) => {\n  const builder = new UPlotConfigBuilder(timeZones[0]);\n\n  const xScaleKey = 'x';\n\n  const isDiscrete = (field: Field) => {\n    const mode = field.config?.color?.mode;\n    return !(mode && field.display && mode.startsWith('continuous-'));\n  };\n  const getValueColorFn = (seriesIdx: number, value: unknown) => {\n    const field = frame.fields[seriesIdx];\n\n    if (\n      field.state?.origin?.fieldIndex !== undefined &&\n      field.state?.origin?.frameIndex !== undefined &&\n      getValueColor\n    ) {\n      return getValueColor(field.state?.origin?.frameIndex, field.state?.origin?.fieldIndex, value);\n    }\n\n    return FALLBACK_COLOR;\n  };\n\n  const opts: TimelineCoreOptions = {\n    mode: mode!,\n    numSeries: frame.fields.length - 1,\n    isDiscrete: (seriesIdx) => isDiscrete(frame.fields[seriesIdx]),\n    hasMappedNull: (seriesIdx) =>\n      hasSpecialMappedValue(frame.fields[seriesIdx], SpecialValueMatch.Null) ||\n      hasSpecialMappedValue(frame.fields[seriesIdx], SpecialValueMatch.NullAndNaN),\n    hasMappedNaN: (seriesIdx) =>\n      hasSpecialMappedValue(frame.fields[seriesIdx], SpecialValueMatch.NaN) ||\n      hasSpecialMappedValue(frame.fields[seriesIdx], SpecialValueMatch.NullAndNaN),\n    mergeValues,\n    rowHeight: rowHeight,\n    colWidth: colWidth,\n    showValue: showValue!,\n    alignValue,\n    theme,\n    label: (seriesIdx) => getFieldDisplayName(frame.fields[seriesIdx], frame),\n    getFieldConfig: (seriesIdx) => frame.fields[seriesIdx].config.custom,\n    getValueColor: getValueColorFn,\n    getTimeRange,\n    // hardcoded formatter for state values\n    formatValue: (seriesIdx, value) => formattedValueToString(frame.fields[seriesIdx].display!(value)),\n    hoverMulti,\n  };\n\n  const coreConfig = getConfig(opts);\n\n  builder.addHook('init', coreConfig.init);\n  builder.addHook('drawClear', coreConfig.drawClear);\n\n  builder.setPrepData((frames) => preparePlotData2(frames[0], getStackingGroups(frames[0])));\n\n  builder.setCursor(coreConfig.cursor);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    range: coreConfig.xRange,\n  });\n\n  builder.addScale({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    orientation: ScaleOrientation.Vertical,\n    direction: ScaleDirection.Up,\n    range: coreConfig.yRange,\n  });\n\n  const xAxisHidden = frame.fields[0].config.custom.axisPlacement === AxisPlacement.Hidden;\n\n  builder.addAxis({\n    show: !xAxisHidden,\n    scaleKey: xScaleKey,\n    isTime: true,\n    splits: coreConfig.xSplits!,\n    placement: AxisPlacement.Bottom,\n    timeZone: timeZones[0],\n    theme,\n  });\n\n  const yCustomConfig = frame.fields[1].config.custom;\n  const yAxisWidth = yCustomConfig.axisWidth;\n  const yAxisHidden = yCustomConfig.axisPlacement === AxisPlacement.Hidden;\n\n  builder.addAxis({\n    scaleKey: FIXED_UNIT, // y\n    isTime: false,\n    placement: AxisPlacement.Left,\n    splits: coreConfig.ySplits,\n    values: yAxisHidden ? (u, splits) => splits.map((v) => null) : coreConfig.yValues,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: yAxisHidden ? 0 : 16,\n    size: yAxisHidden ? 0 : yAxisWidth,\n    theme,\n  });\n\n  let seriesIndex = 0;\n\n  for (let i = 0; i < frame.fields.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n\n    const field = frame.fields[i];\n    const config: FieldConfig<PanelFieldConfig> = field.config;\n    const customConfig: PanelFieldConfig = {\n      ...defaultConfig,\n      ...config.custom,\n    };\n\n    field.state!.seriesIndex = seriesIndex++;\n\n    // const scaleKey = config.unit || FIXED_UNIT;\n    // const colorMode = getFieldColorModeForField(field);\n\n    builder.addSeries({\n      scaleKey: FIXED_UNIT,\n      pathBuilder: coreConfig.drawPaths,\n      pointsBuilder: coreConfig.drawPoints,\n      //colorMode,\n      lineWidth: customConfig.lineWidth,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      show: !customConfig.hideFrom?.viz,\n      thresholds: config.thresholds,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n  }\n\n  return builder;\n};\n\nfunction getSpanNulls(field: Field) {\n  let spanNulls = field.config.custom?.spanNulls;\n\n  // magic value for join() to leave nulls alone instead of expanding null ranges\n  // should be set to -1 when spanNulls = null|undefined|false|0, which is \"retain nulls, without expanding\"\n  // Infinity is not optimal here since it causes spanNulls to be more expensive than simply removing all nulls unconditionally\n  return !spanNulls ? -1 : spanNulls === true ? Infinity : spanNulls;\n}\n\n/**\n * Merge values by the threshold\n */\nexport function mergeThresholdValues(field: Field, theme: GrafanaTheme2): Field | undefined {\n  const thresholds = field.config.thresholds;\n  if (field.type !== FieldType.number || !thresholds || !thresholds.steps.length) {\n    return undefined;\n  }\n\n  const items = getThresholdItems(field.config, theme);\n  if (items.length !== thresholds.steps.length) {\n    return undefined; // should not happen\n  }\n\n  const thresholdToText = new Map<Threshold, string>();\n  const textToColor = new Map<string, string>();\n  for (let i = 0; i < items.length; i++) {\n    thresholdToText.set(thresholds.steps[i], items[i].label);\n    textToColor.set(items[i].label, items[i].color!);\n  }\n\n  let input = field.values;\n  const vals = new Array<String | undefined>(field.values.length);\n  if (thresholds.mode === ThresholdsMode.Percentage) {\n    const { min, max } = getFieldConfigWithMinMax(field);\n    const delta = max! - min!;\n    input = input.map((v) => {\n      if (v == null) {\n        return v;\n      }\n      return ((v - min!) / delta) * 100;\n    });\n  }\n\n  for (let i = 0; i < vals.length; i++) {\n    const v = input[i];\n    if (v == null) {\n      vals[i] = v;\n    } else {\n      vals[i] = thresholdToText.get(getActiveThreshold(v, thresholds.steps));\n    }\n  }\n\n  return {\n    ...field,\n    config: {\n      ...field.config,\n      custom: {\n        ...field.config.custom,\n        spanNulls: getSpanNulls(field),\n      },\n    },\n    type: FieldType.string,\n    values: vals,\n    display: (value) => ({\n      text: String(value),\n      color: textToColor.get(String(value)),\n      numeric: NaN,\n    }),\n  };\n}\n\n// This will return a set of frames with only graphable values included\nexport function prepareTimelineFields(\n  series: DataFrame[] | undefined,\n  mergeValues: boolean,\n  timeRange: TimeRange,\n  theme: GrafanaTheme2\n): { frames?: DataFrame[]; warn?: string } {\n  // this allows PanelDataErrorView to show the default noValue message\n  if (!series?.length) {\n    return { warn: '' };\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let hasTimeseries = false;\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    let startFieldIdx = -1;\n    let endFieldIdx = -1;\n\n    for (let i = 0; i < frame.fields.length; i++) {\n      let f = frame.fields[i];\n\n      if (f.type === FieldType.time && typeof f.values[0] === 'number') {\n        if (startFieldIdx === -1) {\n          startFieldIdx = i;\n        } else if (endFieldIdx === -1) {\n          endFieldIdx = i;\n          break;\n        }\n      }\n    }\n\n    let isTimeseries = startFieldIdx !== -1;\n    let changed = false;\n    frame = maybeSortFrame(frame, startFieldIdx);\n\n    // if we have a second time field, assume it is state end timestamps\n    // and insert nulls into the data at the end timestamps\n    if (endFieldIdx !== -1) {\n      let startFrame: DataFrame = {\n        ...frame,\n        fields: frame.fields.filter((f, i) => i !== endFieldIdx),\n      };\n\n      let endFrame: DataFrame = {\n        length: frame.length,\n        fields: [frame.fields[endFieldIdx]],\n      };\n\n      frame = outerJoinDataFrames({\n        frames: [startFrame, endFrame],\n        keepDisplayNames: true,\n        nullMode: () => NULL_RETAIN,\n      })!;\n\n      frame.fields.forEach((f, i) => {\n        if (i > 0) {\n          let vals = f.values;\n          for (let i = 0; i < vals.length; i++) {\n            if (vals[i] == null) {\n              vals[i] = null;\n            }\n          }\n        }\n      });\n\n      changed = true;\n    }\n\n    let nulledFrame = applyNullInsertThreshold({\n      frame,\n      refFieldPseudoMin: timeRange.from.valueOf(),\n      refFieldPseudoMax: timeRange.to.valueOf(),\n    });\n\n    if (nulledFrame !== frame) {\n      changed = true;\n    }\n\n    frame = nullToValue(nulledFrame);\n\n    const fields: Field[] = [];\n    for (let field of frame.fields) {\n      switch (field.type) {\n        case FieldType.time:\n          if (typeof field.values[0] === 'number') {\n            isTimeseries = true;\n            hasTimeseries = true;\n            fields.push(field);\n          }\n          break;\n        case FieldType.enum:\n        case FieldType.number:\n          if (mergeValues && field.config.color?.mode === FieldColorModeId.Thresholds) {\n            const f = mergeThresholdValues(field, theme);\n            if (f) {\n              fields.push(f);\n              changed = true;\n              continue;\n            }\n          }\n\n        case FieldType.boolean:\n        case FieldType.string:\n          field = {\n            ...field,\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                spanNulls: getSpanNulls(field),\n              },\n            },\n          };\n          changed = true;\n          fields.push(field);\n          break;\n        default:\n          changed = true;\n      }\n    }\n    if (isTimeseries && fields.length > 1) {\n      hasTimeseries = true;\n      if (changed) {\n        frames.push({\n          ...frame,\n          fields,\n        });\n      } else {\n        frames.push(frame);\n      }\n    }\n  }\n\n  if (!hasTimeseries) {\n    return { warn: t('timeline.missing-field.time', 'Data does not have a time field') };\n  }\n  if (!frames.length) {\n    return { warn: t('timeline.missing-field.all', 'No graphable fields') };\n  }\n\n  return { frames };\n}\n\nexport function makeFramePerSeries(frames: DataFrame[]) {\n  const outFrames: DataFrame[] = [];\n\n  for (let frame of frames) {\n    const timeFields = frame.fields.filter((field) => field.type === FieldType.time);\n\n    if (timeFields.length > 0) {\n      for (let field of frame.fields) {\n        if (field.type !== FieldType.time) {\n          outFrames.push({ fields: [...timeFields, field], length: frame.length });\n        }\n      }\n    }\n  }\n\n  return outFrames;\n}\n\nexport function getThresholdItems(\n  fieldConfig: FieldConfig,\n  theme: GrafanaTheme2,\n  thresholdItems?: ThresholdsConfig\n): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  const thresholds = thresholdItems ? thresholdItems : fieldConfig.thresholds;\n  if (!thresholds || !thresholds.steps.length) {\n    return items;\n  }\n\n  const steps = thresholds.steps;\n  const getDisplay = getValueFormat(\n    thresholds.mode === ThresholdsMode.Percentage ? 'percent' : (fieldConfig.unit ?? '')\n  );\n\n  // `undefined` value for decimals will use `auto`\n  const format = (value: number) => formattedValueToString(getDisplay(value, fieldConfig.decimals ?? undefined));\n\n  for (let i = 0; i < steps.length; i++) {\n    let step = steps[i];\n    let value = step.value;\n    let pre = '';\n    let suf = '';\n\n    if (value === -Infinity && i < steps.length - 1) {\n      value = steps[i + 1].value;\n      pre = '< ';\n    } else {\n      suf = '+';\n    }\n\n    items.push({\n      label: `${pre}${format(value)}${suf}`,\n      color: theme.visualization.getColorByName(step.color),\n      yAxis: 1,\n    });\n  }\n\n  return items;\n}\n\nexport function getValueMappingItems(mappings: ValueMapping[], theme: GrafanaTheme2): VizLegendItem[] {\n  const items: VizLegendItem[] = [];\n  if (!mappings) {\n    return items;\n  }\n\n  for (let mapping of mappings) {\n    const { options, type } = mapping;\n\n    if (type === MappingType.ValueToText) {\n      for (let [label, value] of Object.entries(options)) {\n        const color = value.color;\n        items.push({\n          label: label,\n          color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n          yAxis: 1,\n        });\n      }\n    }\n\n    if (type === MappingType.RangeToText) {\n      const { from, result, to } = options;\n      const { text, color } = result;\n      const label = text ? `[${from} - ${to}] ${text}` : `[${from} - ${to}]`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n\n    if (type === MappingType.RegexToText) {\n      const { pattern, result } = options;\n      const { text, color } = result;\n      const label = `${text || pattern}`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n\n    if (type === MappingType.SpecialValue) {\n      const { match, result } = options;\n      const { text, color } = result;\n      const label = `${text || match}`;\n\n      items.push({\n        label: label,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  }\n\n  return items;\n}\n\nexport function prepareTimelineLegendItems(\n  frames: DataFrame[] | undefined,\n  options: VizLegendOptions,\n  theme: GrafanaTheme2\n): VizLegendItem[] | undefined {\n  if (!frames || options.showLegend === false) {\n    return undefined;\n  }\n\n  return getFieldLegendItem(allNonTimeFields(frames), theme);\n}\n\nexport function getFieldLegendItem(fields: Field[], theme: GrafanaTheme2): VizLegendItem[] | undefined {\n  if (!fields.length) {\n    return undefined;\n  }\n\n  const items: VizLegendItem[] = [];\n  const fieldConfig = fields[0].config;\n  const colorMode = fieldConfig.color?.mode ?? FieldColorModeId.Fixed;\n  const thresholds = fieldConfig.thresholds;\n\n  // If thresholds are enabled show each step in the legend\n  // This ignores the hide from legend since the range is valid\n  if (colorMode === FieldColorModeId.Thresholds && thresholds?.steps && thresholds.steps.length > 1) {\n    return getThresholdItems(fieldConfig, theme);\n  }\n\n  // If thresholds are enabled show each step in the legend\n  if (colorMode.startsWith('continuous')) {\n    return undefined; // eventually a color bar\n  }\n\n  const stateColors: Map<string, string | undefined> = new Map();\n\n  fields.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.legend) {\n      field.values.forEach((v) => {\n        let state = field.display!(v);\n        if (state.color) {\n          stateColors.set(state.text, state.color!);\n        }\n      });\n    }\n  });\n\n  stateColors.forEach((color, label) => {\n    if (label.length > 0) {\n      items.push({\n        label: label!,\n        color: theme.visualization.getColorByName(color ?? FALLBACK_COLOR),\n        yAxis: 1,\n      });\n    }\n  });\n\n  return items;\n}\n\nfunction allNonTimeFields(frames: DataFrame[]): Field[] {\n  const fields: Field[] = [];\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type !== FieldType.time) {\n        fields.push(field);\n      }\n    }\n  }\n  return fields;\n}\n\nexport function findNextStateIndex(field: Field, datapointIdx: number) {\n  let end;\n  let rightPointer = datapointIdx + 1;\n\n  if (rightPointer >= field.values.length) {\n    return null;\n  }\n\n  const startValue = field.values[datapointIdx];\n\n  while (end === undefined) {\n    if (rightPointer >= field.values.length) {\n      return null;\n    }\n    const rightValue = field.values[rightPointer];\n\n    if (rightValue === undefined || rightValue === startValue) {\n      rightPointer++;\n    } else {\n      end = rightPointer;\n    }\n  }\n\n  return end;\n}\n\n/**\n * Returns the precise duration of a time range passed in milliseconds.\n * This function calculates with 30 days month and 365 days year.\n * adapted from https://gist.github.com/remino/1563878\n * @param milliSeconds The duration in milliseconds\n * @returns A formatted string of the duration\n */\nexport function fmtDuration(milliSeconds: number): string {\n  if (milliSeconds < 0 || Number.isNaN(milliSeconds)) {\n    return '';\n  }\n\n  let yr: number, mo: number, wk: number, d: number, h: number, m: number, s: number, ms: number;\n\n  s = Math.floor(milliSeconds / 1000);\n  m = Math.floor(s / 60);\n  s = s % 60;\n  h = Math.floor(m / 60);\n  m = m % 60;\n  d = Math.floor(h / 24);\n  h = h % 24;\n\n  yr = Math.floor(d / 365);\n  if (yr > 0) {\n    d = d % 365;\n  }\n\n  mo = Math.floor(d / 30);\n  if (mo > 0) {\n    d = d % 30;\n  }\n\n  wk = Math.floor(d / 7);\n\n  if (wk > 0) {\n    d = d % 7;\n  }\n\n  ms = Math.round((milliSeconds % 1000) * 1000) / 1000;\n\n  return (\n    yr > 0\n      ? yr + 'y ' + (mo > 0 ? mo + 'mo ' : '') + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n      : mo > 0\n        ? mo + 'mo ' + (wk > 0 ? wk + 'w ' : '') + (d > 0 ? d + 'd ' : '')\n        : wk > 0\n          ? wk + 'w ' + (d > 0 ? d + 'd ' : '')\n          : d > 0\n            ? d + 'd ' + (h > 0 ? h + 'h ' : '')\n            : h > 0\n              ? h + 'h ' + (m > 0 ? m + 'm ' : '')\n              : m > 0\n                ? m + 'm ' + (s > 0 ? s + 's ' : '')\n                : s > 0\n                  ? s + 's ' + (ms > 0 ? ms + 'ms ' : '')\n                  : ms > 0\n                    ? ms + 'ms '\n                    : '0'\n  ).trim();\n}\n","const MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nexport type Quads = [Quadtree, Quadtree, Quadtree, Quadtree];\nexport type Rect = { x: number; y: number; w: number; h: number; [_: string]: any };\n\n/**\n * @internal\n */\nexport function pointWithin(px: number, py: number, rlft: number, rtop: number, rrgt: number, rbtm: number) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\n/**\n * @internal\n */\nexport function findRects(qt: Quadtree, sidx?: number, didx?: number) {\n  let rects: Rect[] = [];\n\n  if (qt.o.length) {\n    rects.push(...qt.o.filter((rect) => (sidx == null || rect.sidx === sidx) && (didx == null || rect.didx === didx)));\n  }\n\n  if (qt.q) {\n    for (let i = 0; i < qt.q.length; i++) {\n      rects.push(...findRects(qt.q[i], sidx, didx));\n    }\n  }\n\n  return rects;\n}\n\n/**\n * @internal\n *\n * Determines if r2 is intersected by r1.\n */\nexport function intersects(r1: Rect, r2: Rect) {\n  return r1.x <= r2.x + r2.w && r1.x + r1.w >= r2.x && r1.y + r1.h >= r2.y && r1.y <= r2.y + r2.h;\n}\n\n/**\n * @internal\n */\nexport class Quadtree {\n  o: Rect[];\n  q: Quads | null;\n\n  constructor(\n    public x: number,\n    public y: number,\n    public w: number,\n    public h: number,\n    public l = 0\n  ) {\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let t = this,\n      x = t.x,\n      y = t.y,\n      w = t.w / 2,\n      h = t.h / 2,\n      l = t.l + 1;\n\n    t.q = [\n      // top right\n      new Quadtree(x + w, y, w, h, l),\n      // top left\n      new Quadtree(x, y, w, h, l),\n      // bottom left\n      new Quadtree(x, y + h, w, h, l),\n      // bottom right\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  // invokes callback with index of each overlapping quad\n  quads(x: number, y: number, w: number, h: number, cb: (q: Quadtree) => void) {\n    let t = this,\n      q = t.q!,\n      hzMid = t.x + t.w / 2,\n      vtMid = t.y + t.h / 2,\n      startIsNorth = y < vtMid,\n      startIsWest = x < hzMid,\n      endIsEast = x + w > hzMid,\n      endIsSouth = y + h > vtMid;\n\n    // top-right quad\n    startIsNorth && endIsEast && cb(q[0]);\n    // top-left quad\n    startIsWest && startIsNorth && cb(q[1]);\n    // bottom-left quad\n    startIsWest && endIsSouth && cb(q[2]);\n    // bottom-right quad\n    endIsEast && endIsSouth && cb(q[3]);\n  }\n\n  add(o: Rect) {\n    let t = this;\n\n    if (t.q != null) {\n      t.quads(o.x, o.y, o.w, o.h, (q) => {\n        q.add(o);\n      });\n    } else {\n      let os = t.o;\n\n      os.push(o);\n\n      if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {\n        t.split();\n\n        for (let i = 0; i < os.length; i++) {\n          let oi = os[i];\n\n          t.quads(oi.x, oi.y, oi.w, oi.h, (q) => {\n            q.add(oi);\n          });\n        }\n\n        t.o.length = 0;\n      }\n    }\n  }\n\n  get(x: number, y: number, w: number, h: number, cb: (o: Rect) => void) {\n    let t = this;\n    let os = t.o;\n\n    for (let i = 0; i < os.length; i++) {\n      cb(os[i]);\n    }\n\n    if (t.q != null) {\n      t.quads(x, y, w, h, (q) => {\n        q.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n"],"names":["SPACE_BETWEEN","SPACE_AROUND","SPACE_EVENLY","coord","i","offs","iwid","gap","distribute","numItems","sizeFactor","justify","onlyIdx","each","space","_iwid","round","min","ceil","textPadding","pxPerChar","laneDistr","walk","rowHeight","yIdx","count","dim","draw","offPct","dimPct","laneOffPx","laneWidPx","shouldDrawYValue","yValue","mappedNull","mappedNaN","getConfig","opts","mode","numSeries","isDiscrete","hasMappedNull","hasMappedNaN","colWidth","showValue","mergeValues","theme","label","formatValue","alignValue","getTimeRange","getValueColor","getFieldConfig","hoverMulti","qt","boxRectsBySeries","resetBoxRectsBySeries","v","font","hovered","hoveredAtCursor","size","gapFactor","maxWidth","fillPaths","strokePaths","drawBoxes","ctx","fillPath","fillStyle","strokePath","strokeStyle","putBox","rect","xOff","yOff","left","top","boxWidth","boxHeight","strokeWidth","seriesIdx","valueIdx","value","discrete","valueColor","fieldConfig","fillColor","getFillColor","drawPaths","u","sidx","idx0","idx1","series","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xDim","yDim","moveTo","lineTo","iy","y0","height","TimelineMode","ix","yVal","nextIx","right","colWid","gapWid","barWid","xShift","drawPoints","i0","i1","y","ySplits","boxRect","displayedBoxWidth","maxChars","txt","x","init","chars","el","drawClear","s","setHovered","cx","cy","viaSync","o","cursor","seriesRects","hRect","isHovered","yRange","axisIdx","scaleMin","scaleMax","foundIncr","foundSpace","splits","dataIncr","skipFactor","r","max","scalePad","lastIdx","hgt","yMid","color","opacityPercent","colorManipulator","defaultConfig","hasSpecialMappedValue","field","match","mapping","preparePlotConfigBuilder","frame","timeZones","builder","UPlotConfigBuilder","xScaleKey","getValueColorFn","coreConfig","frames","xAxisHidden","yCustomConfig","yAxisWidth","yAxisHidden","seriesIndex","config","customConfig","getSpanNulls","spanNulls","mergeThresholdValues","thresholds","items","getThresholdItems","thresholdToText","textToColor","input","vals","delta","prepareTimelineFields","timeRange","hasTimeseries","startFieldIdx","endFieldIdx","f","isTimeseries","changed","startFrame","endFrame","nulledFrame","nullToValue","fields","makeFramePerSeries","outFrames","timeFields","thresholdItems","steps","getDisplay","format","step","pre","suf","getValueMappingItems","mappings","options","type","from","result","to","text","pattern","prepareTimelineLegendItems","getFieldLegendItem","allNonTimeFields","colorMode","stateColors","state","findNextStateIndex","datapointIdx","end","rightPointer","startValue","rightValue","fmtDuration","milliSeconds","yr","mo","wk","d","h","m","ms","MAX_OBJECTS","MAX_LEVELS","pointWithin","px","py","rlft","rtop","rrgt","rbtm","findRects","didx","rects","intersects","r1","r2","Quadtree","w","l","t","cb","q","hzMid","vtMid","startIsNorth","startIsWest","endIsEast","endIsSouth","os","oi"],"sourceRoot":""}